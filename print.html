<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Overview</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="exception_handling/index.html"><strong aria-hidden="true">2.</strong> Exception Handling</a></li><li class="chapter-item expanded "><a href="memory_management/index.html"><strong aria-hidden="true">3.</strong> Memory Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory_management/contiguous_memory_allocation.html"><strong aria-hidden="true">3.1.</strong> Contiguous Memory Allocation</a></li><li class="chapter-item expanded "><a href="memory_management/noncontiguous_memory_allocation.html"><strong aria-hidden="true">3.2.</strong> Non-contiguous Memory Allocation</a></li></ol></li><li class="chapter-item expanded "><a href="virtual_memory/index.html"><strong aria-hidden="true">4.</strong> Virtual Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="virtual_memory/preliminary_concepts.html"><strong aria-hidden="true">4.1.</strong> Preliminary Concepts</a></li><li class="chapter-item expanded "><a href="virtual_memory/local_replacement.html"><strong aria-hidden="true">4.2.</strong> Local Replacement</a></li><li class="chapter-item expanded "><a href="virtual_memory/global_replacement.html"><strong aria-hidden="true">4.3.</strong> Global Replacement</a></li></ol></li><li class="chapter-item expanded "><a href="processes_and_threads/index.html"><strong aria-hidden="true">5.</strong> Processes and Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="processes_and_threads/processes.html"><strong aria-hidden="true">5.1.</strong> Processes</a></li><li class="chapter-item expanded "><a href="processes_and_threads/threads.html"><strong aria-hidden="true">5.2.</strong> Threads</a></li><li class="chapter-item expanded "><a href="processes_and_threads/scheduling.html"><strong aria-hidden="true">5.3.</strong> Scheduling</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency/index.html"><strong aria-hidden="true">6.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concurrency/mutual_exclusion_and_synchronization.html"><strong aria-hidden="true">6.1.</strong> Mutual Exclusion and Synchronization</a></li><li class="chapter-item expanded "><a href="concurrency/semaphore.html"><strong aria-hidden="true">6.2.</strong> Semaphore</a></li><li class="chapter-item expanded "><a href="concurrency/deadlock_and_starvation.html"><strong aria-hidden="true">6.3.</strong> Deadlock and Starvation</a></li><li class="chapter-item expanded "><a href="concurrency/interprocess_communication.html"><strong aria-hidden="true">6.4.</strong> Interprocess Communication</a></li></ol></li><li class="chapter-item expanded "><a href="file_system/index.html"><strong aria-hidden="true">7.</strong> File System</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>There are some simple notes of <em>Operating System</em>. Most contents are copied from slides.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="isolation"><a class="header" href="#isolation">Isolation</a></h2>
<ul>
<li>强制隔离以避免对整个系统的可用性、可靠性和安全影响</li>
<li>运行的程序通常是隔离的单元</li>
<li>防止程序 X 破坏或监视程序 Y
<ul>
<li>读/写内存，使用 100% CPU，更改文件描述符</li>
</ul>
</li>
<li>防止进程干扰操作系统</li>
<li>防止恶意程序、病毒、木马和 bug
<ul>
<li>错误的过程可能会试图欺骗硬件或内核</li>
</ul>
</li>
</ul>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<ul>
<li>地址空间
<ul>
<li>一个程序仅寻址其自己的内存</li>
<li>每个程序若无许可，则无法访问不属于自己的内存</li>
</ul>
</li>
<li>CPU 硬件中的特权模式/中断机制
<ul>
<li>防止应用程序访问设备和敏感的 CPU 寄存器</li>
<li>例如地址空间配置寄存器</li>
<li>例如打断一直占用 CPU 的应用程序</li>
</ul>
</li>
</ul>
<h2 id="program-call"><a class="header" href="#program-call">Program Call</a></h2>
<ul>
<li>好处
<ul>
<li>执行很快</li>
<li>灵活且易于传递和返回复杂数据类型</li>
<li>程序员熟悉的机制</li>
</ul>
</li>
<li>坏处
<ul>
<li>应用程序不可靠，可能有崩溃的风险</li>
</ul>
</li>
</ul>
<h2 id="interrupt"><a class="header" href="#interrupt">Interrupt</a></h2>
<ul>
<li>CPU 硬件支持中断、异常的处理</li>
<li>中断是异步发生的，是来自处理器外部的 I/O 设备的信号结果
<ul>
<li>硬件中断不是由任意一条专门的 CPU 指令造成，从这个意义上它是异步的</li>
</ul>
</li>
<li>硬件中断的异常处理程序通常称为中断处理程序
<ul>
<li>I/O 设备通过向处理器芯片的一个引脚发信号，并将异常信号放到系统总线上以触发中断</li>
<li>在当前指令执行完后，处理器从系统总线读取异常号，保存现场，切换到 Kernel Mode</li>
<li>调用中断处理程序，当中断处理程序完成后，它将控制返回到下一条本来要执行的指令</li>
</ul>
</li>
<li>Timer 可以稳定定时地产生中断
<ul>
<li>防止应用程序一直占用 CPU</li>
<li>让 OS Kernel 能周期性地进行资源管理</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h1>
<h2 id="basic-principles-and-concepts"><a class="header" href="#basic-principles-and-concepts">Basic principles and concepts</a></h2>
<ul>
<li>System Call: 应用程序<strong>主动</strong>向操作系统发出服务请求。</li>
<li>Exception: 由于非法指令或其他原因导致<strong>当前指令执行失败</strong>，（如：内存出错）后的处理请求。</li>
<li>Hardware Interrupt: 来自硬件设备的处理请求。</li>
</ul>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<ul>
<li>源头：
<ul>
<li>中断：外设</li>
<li>异常：应用程序意想不到的行为</li>
<li>系统调用：应用程序请求 OS 服务</li>
</ul>
</li>
<li>相应方式
<ul>
<li>中断：异步</li>
<li>异常：同步</li>
<li>系统调用：异步或同步</li>
</ul>
</li>
<li>处理机制
<ul>
<li>中断：持续且对应用程序透明</li>
<li>异常：杀死或重新继续执行</li>
<li>系统调用：等待和持续</li>
</ul>
</li>
</ul>
<h2 id="interrupt-handling"><a class="header" href="#interrupt-handling">Interrupt Handling</a></h2>
<h3 id="establish-interrupt-mechanisms"><a class="header" href="#establish-interrupt-mechanisms">Establish Interrupt Mechanisms</a></h3>
<ul>
<li>建立中断服务例程
<ul>
<li>初始化
<ul>
<li>设置时钟中断触发次数</li>
<li>设置 <code>sie</code> 的 TI 使能 STIE 位</li>
</ul>
</li>
<li>服务例程
<ul>
<li>调用 OpenSBI 提供的接口设置下次时钟中断触发时间</li>
</ul>
</li>
</ul>
</li>
<li>让 CPU 能响应中断
<ul>
<li>硬件设置
<ul>
<li>sstatus: 保存全局中断的使能位</li>
<li>sie: 指出 CPU 目前能处理或忽略的中断</li>
<li>stvec: 中断入口地址</li>
</ul>
</li>
<li>初始化
<ul>
<li>设定 <code>sie</code> 的 TI 使能 STIE 位</li>
<li>设定 <code>sstatus</code> 的使能中断 SIE 位</li>
<li>实现中断服务总控函数</li>
<li>设置 <code>stvec</code> 指向中断服务总控函数的入口地址</li>
</ul>
</li>
</ul>
</li>
<li>相应并处理中断
<ul>
<li>硬件设置
<ul>
<li>sepc: 保存中断的指令地址</li>
<li>pc: 设置为 <code>stvec</code></li>
<li>scause: 设置中断的来源</li>
<li>sstatus: SIE 位置零以禁用中断</li>
<li>stval: 保存了中断相关的附加信息</li>
</ul>
</li>
<li>软件保存
<ul>
<li>x[0-32]: 通用寄存器</li>
<li>pc: 设置为 <code>stvec</code></li>
<li>scause: 设置为中断的来源</li>
<li>sstatus: SIE 位置零以禁用中断</li>
<li>stval: 保存了中断相关的附加信息</li>
</ul>
</li>
<li>产生中断后
<ul>
<li>硬件设置</li>
<li>软件保存被打断现场</li>
<li>执行软件实现的中断服务例程</li>
<li>软件恢复被打断现场</li>
<li>继续执行</li>
</ul>
</li>
<li>硬件中断服务例程可被打断
<ul>
<li>不同硬件中断源可能在硬件中断处理时出现</li>
<li>中断请求会保持到 CPU 做出响应</li>
<li>硬件中断服务例程中需要临时禁止中断请求</li>
</ul>
</li>
</ul>
</li>
<li>保存或恢复现场
<ul>
<li>还需要为被中断的服务保存和恢复当时程序运行时的上下文
<ul>
<li>x[0-32]: 通用寄存器</li>
<li>sstatus: 系统系状态</li>
<li>sepc: 触发异常/中断的指令地址</li>
<li>scause: 指示发生异常/中断的种类</li>
<li>stval: 保存了发生异常/中断的附加信息</li>
</ul>
</li>
<li>SAVE_ALL 寄存器</li>
</ul>
</li>
</ul>
<h2 id="system-call"><a class="header" href="#system-call">System Call</a></h2>
<p>When an application wants to print a string, it will trigger the system call <code>write()</code>.</p>
<ul>
<li>系统调用
<ul>
<li>在 RISC-V 中，<code>ecall</code> 和 <code>sret</code> 指令用于系统调用</li>
<li>堆栈切换和特权级的转换</li>
</ul>
</li>
<li>函数调用
<ul>
<li>在 RISC-V 中，<code>call</code> 和 <code>ret</code> 指令用于系统调用</li>
<li>无堆栈切换和特权级的转换</li>
</ul>
</li>
</ul>
<h3 id="expenditure-of-system-call"><a class="header" href="#expenditure-of-system-call">Expenditure of System Call</a></h3>
<p>开销会超过函数调用，主要来源：</p>
<ul>
<li>切换内核堆栈</li>
<li>验证参数</li>
<li>切换页表</li>
<li>拷贝数据</li>
</ul>
<h3 id="implementation-of-system-call"><a class="header" href="#implementation-of-system-call">Implementation of System Call</a></h3>
<ul>
<li>应用发起请求</li>
<li><code>std lib</code> 发出系统调用请求
<ul>
<li>发出设置系统调用号和参数，发出 <code>ecall</code></li>
</ul>
</li>
<li>硬件设置
<ul>
<li>sepc：保存请求后的指令地址</li>
<li>pc: 设置为 <code>stvec</code></li>
<li>scause: 设置为 <code>ecall from u-mode</code></li>
<li>sstauts: SIE 位置零以禁用中断</li>
<li>stval: 保存了相关的附件信息</li>
</ul>
</li>
<li>软件保存被打断现场</li>
<li>执行软件实现的中断服务例程</li>
<li>软件恢复现场</li>
<li>应用继续执行</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>In a uniprogramming system, main memory is divided into two parts: one part
for the operating system (resident monitor, kernel) and other part for the program
currently being executed. In a multiprogramming system, the “user” part of
memory must be further subdivided to accommodate multiple processes. The task
of subdivision is carried out dynamically by the operating system and is known as
memory management.</p>
<p>Effective memory management is vital in a multiprogramming system. If only
a few processes are in memory, then for much of the time all of the processes will be
waiting for I/O (input/output), and the processor will be idle. Thus, memory needs to
be allocated to ensure a reasonable supply of ready processes to consume available
processor time.</p>
<p>In this chapter, some key concepts about <strong>contiguous memory allocation</strong> and <strong>non-contiguous memory allocation</strong> will be discussed.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="contiguous-memory-allocation"><a class="header" href="#contiguous-memory-allocation">Contiguous Memory Allocation</a></h1>
<h2 id="the-memory-hierarchy"><a class="header" href="#the-memory-hierarchy">The Memory Hierarchy</a></h2>
<p>A typical hierarchy is illustrated in figure below.</p>
<p><img src="memory_management/./assets/the_memory_hierarchy.png" alt="The Memory Hierarchy" /></p>
<p>As one goes down the hierarchy, the following occur:</p>
<ul>
<li>Decreasing cost per bit</li>
<li>Increasing capacity</li>
<li>Increasing access time</li>
<li>Decreasing frequency of access to the memory by the processor</li>
</ul>
<h2 id="cache-memory"><a class="header" href="#cache-memory">Cache Memory</a></h2>
<p>Although cache memory is invisible to the OS, it interacts with other memory management hardware.</p>
<h2 id="cache-principles"><a class="header" href="#cache-principles">Cache Principles</a></h2>
<p>Cache memory is intended to provide memory access time approaching that of the fastest memories available, and at the same time support a large memory size that has the price of less expensive types of semiconductor memories. The concept is illustrated in the Figure below</p>
<p><img src="memory_management/./assets/single_cache.png" alt="Single Cache" /></p>
<p>There is a relatively large and slow main memory together with a smaller, faster cache memory.</p>
<p>The next figure depicts the use of multiple levels of cache.</p>
<p><img src="memory_management/./assets/three-level_cache_organization.png" alt="Three-level Cache Organization" /></p>
<p>Main memory consists of up to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> addressable words, with each word having a unique <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>-bit address. For mapping purposes, this memory is considered to consist of a number of fixed length <strong>blocks</strong>
of K words each. That is there are <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> blocks. Cache consists of C <strong>slots</strong> (<em>lines</em>) of K words each, and the number of slots is considerably less than the number of main memory blocks (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>).</p>
<p><img src="memory_management/./assets/cache_main_memory_structure.png" alt="Cache/Main Memory Structure" /></p>
<h2 id="memory-management-methods"><a class="header" href="#memory-management-methods">Memory Management Methods</a></h2>
<ul>
<li>Relocation</li>
<li>Segmentation</li>
<li>Paging</li>
<li>Virtual Memory</li>
</ul>
<h2 id="address-space"><a class="header" href="#address-space">Address Space</a></h2>
<p>The range of addresses available to a computer program.</p>
<ul>
<li>
<p>A logical address is a reference to a memory location <strong>independent</strong> of the current assignment of data to memory; a translation must be made to a physical address before the memory access can be achieved.</p>
</li>
<li>
<p>A relative address is a particular
example of logical address, in which the address is expressed as a location relative to some known point, usually a value in a processor register.</p>
</li>
<li>
<p>A physical address, or absolute address is an <strong>actual</strong> location in main memory.</p>
</li>
</ul>
<h3 id="generating-logical-address"><a class="header" href="#generating-logical-address">Generating Logical Address</a></h3>
<ul>
<li>Compile</li>
<li>Assemble</li>
<li>Link</li>
<li>Relocation</li>
</ul>
<h3 id="procedures"><a class="header" href="#procedures">Procedures</a></h3>
<ul>
<li>CPU
<ul>
<li>ALU: 需要逻辑地址的内存内容</li>
<li>MMU：进行逻辑地址和物理地址的转换</li>
<li>CPU 控制逻辑：给总线发送物理地址请求</li>
</ul>
</li>
<li>内存： 发送物理地址的内容给 CPU 或接受 CPU 数据到物理地址</li>
<li>操作系统：建立逻辑地址与物理地址的映射</li>
</ul>
<h3 id="address-check"><a class="header" href="#address-check">Address Check</a></h3>
<p><img src="memory_management/./assets/address_check.png" alt="Address Check" /></p>
<h2 id="memory-partitioning"><a class="header" href="#memory-partitioning">Memory Partitioning</a></h2>
<p>The principal operation of memory management is to bring processes into main memory for execution by the processor.</p>
<h3 id="fixed-partitioning"><a class="header" href="#fixed-partitioning">Fixed Partitioning</a></h3>
<p>In most schemes for memory management, we can assume the OS occupies some fixed portion of main memory, and the rest of main memory is available for use by multiple processes. The simplest scheme for managing this available memory is to partition it into regions with fixed boundaries.</p>
<h4 id="description"><a class="header" href="#description">Description</a></h4>
<p>Main memory is divided into a number of static partitions <em>at system generation time</em>. A process may be loaded into a partition of <em>equal or greater size</em>.</p>
<h4 id="strengths"><a class="header" href="#strengths">Strengths</a></h4>
<p>Simple to implement; little operating system overhead.</p>
<h4 id="weaknesses"><a class="header" href="#weaknesses">Weaknesses</a></h4>
<p>Inefficient use of memory due to internal fragmentation; maximum number of active processes is fixed.</p>
<p><img src="memory_management/./assets/example_of_fixed_partitioning.png" alt="Example of Fixed Partitioning" /></p>
<p>With unequal-size partitions, there are two possible ways to assign processes to partitions. The simplest way is to assign each process to the smallest partition within which it will fit. In this case, a scheduling queue is needed for each partition to hold swapped-out processes destined for that partition</p>
<h3 id="internal-fragmentation"><a class="header" href="#internal-fragmentation">Internal Fragmentation</a></h3>
<p>Occurs when memory is divided into fixed-size partitions (e.g., page frames in main memory, physical blocks on disk). If a block of data is assigned to one or more partitions, then there may be wasted space in the last partition. This will occur if the last portion of data is smaller than the last partition.</p>
<h3 id="external-fragmentation"><a class="header" href="#external-fragmentation">External Fragmentation</a></h3>
<p>Occurs when memory is divided into variable-size partitions corresponding to the blocks of data assigned to the memory (e.g., segments in main memory). As segments are moved into and out of the memory, gaps will occur between the occupied portions of memory.</p>
<h3 id="dynamic-partitioning"><a class="header" href="#dynamic-partitioning">Dynamic Partitioning</a></h3>
<h4 id="description-1"><a class="header" href="#description-1">Description</a></h4>
<p>Partitions are created dynamically, so each process is loaded into a partition of exactly the same size as that process. Data structure is used in dynamic partitioning to maintain allocated blocks and empty blocks.</p>
<h4 id="strengths-1"><a class="header" href="#strengths-1">Strengths</a></h4>
<p>No internal fragmentation; more efficient use of main memory.</p>
<h4 id="weaknesses-1"><a class="header" href="#weaknesses-1">Weaknesses</a></h4>
<p>Inefficient use of processor due to the need for compaction to counter external fragmentation.</p>
<h4 id="placement-algorithms"><a class="header" href="#placement-algorithms">Placement Algorithms</a></h4>
<p>Three placement algorithms that might be considered are <strong>best-fit, first-fit, and next-fit</strong>. All, of course, are limited to choosing among free blocks of main memory that are equal to or larger than the process to be brought in. <strong>Best-fit</strong> chooses the block that is closest in size to the request. <strong>First-fit</strong> begins to scan memory from the beginning and chooses the first available block that is large enough. <strong>Next-fit</strong> begins to scan memory from the location of the last placement and chooses the next available block that is large enough.</p>
<ul>
<li>
<p>Best-fit: 分配 n 字节的分区时，查找并使用不小于 n 的最小空闲分区</p>
<ul>
<li>原理及实现
<ul>
<li>空闲分区列表按大小排序</li>
<li>分配时查找一个合适的分区</li>
<li>释放时查找并合并邻近的空闲分区</li>
</ul>
</li>
<li>优点
<ul>
<li>大部分分配块的尺寸较小时效果较好</li>
<li>可避免大的空闲分区被拆分</li>
<li>可减小外部碎片的大小</li>
<li>实现简单</li>
</ul>
</li>
<li>缺点
<ul>
<li>容易产生外部碎片</li>
<li>释放分区速度较慢</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Worst-fit: 分配 n 字节，使用尺寸不小于 n 的最大空闲分区</p>
<ul>
<li>
<p>原理及实现</p>
<ul>
<li>空闲分区列表按由大到小排序</li>
<li>分配时，选最大的分区</li>
<li>释放时，尽可能与邻近分区合并，并调整空闲分区列表顺序</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>中等大小的分配请求较多时，效果最好</li>
<li>不会出现太多的小碎片</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>释放分区速度较慢</li>
<li>容易产生外部碎片</li>
<li>容易破坏大的空闲分区</li>
</ul>
</li>
</ul>
</li>
<li>
<p>First-fit: 分配 n 个字节，使用第一个可用的空间比 n 大的空闲块。</p>
<ul>
<li>原理及实现
<ul>
<li>空闲分区列表按地址顺序排序</li>
<li>分配时，选第一个合适的分区</li>
<li>释放时，尽可能与邻近分区合并</li>
</ul>
</li>
<li>优点
<ul>
<li>实现简单</li>
<li>在高地址空间有大块的空闲分区</li>
</ul>
</li>
<li>缺点
<ul>
<li>分配大块空间速度较慢</li>
<li>容易产生外部碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="defragmentation"><a class="header" href="#defragmentation">Defragmentation</a></h3>
<p>通过调整进程占用的分区位置来减少或避免分区碎片。</p>
<h4 id="compaction"><a class="header" href="#compaction">Compaction</a></h4>
<p>通过移动分配给进程的内存分区，以合并外部碎片。<br />
碎片紧凑的条件：所有的应用程序可动态重定位。</p>
<h4 id="swapping-inout"><a class="header" href="#swapping-inout">Swapping in/out</a></h4>
<p>通过抢占并回收处于等待状态进程的分区，以增大可用内存空间</p>
<h2 id="buddy-system"><a class="header" href="#buddy-system">Buddy System</a></h2>
<p>Both fixed and dynamic partitioning schemes have drawbacks. A fixed partitioning scheme limits the number of active processes and may use space inefficiently if there is a poor match between available partition sizes and process sizes. A dynamic partitioning scheme is more complex to maintain and includes the overhead of compaction. An interesting compromise is the buddy system.
In a buddy system, memory blocks are available of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span> words, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>, where</p>
<ul>
<li>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> small size block that allocated</p>
</li>
<li>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> largest size block that is allocated; generally <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> is the size of the entire memory available for allocation</p>
</li>
</ul>
<p>To begin, the entire space available for allocation is treated as a single block of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span>. If a request of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> such that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> is made, then the entire block is allocated. Otherwise, the block is split into two equal buddies of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>. This process continues until the smallest block greater than or equal to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> is generated and allocated to the request. At any time, the buddy system maintains a list of holes (unallocated blocks) of each size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>. A hole may be removed from the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> list by splitting it in half to create two buddies of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span> in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> list. Whenever a pair of buddies on the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> list both become unallocated,they are removed from that list and coalesced into a single block on the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> list. Presented with a request for an allocation of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> such that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.863764em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>.<br />
The Figure below gives an example using a 1-Mbyte initial block.</p>
<p><img src="memory_management/./assets/example_of_buddy_system.png" alt="Example of Buddy System" /></p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<ul>
<li>数据结构
<ul>
<li>空闲块按大小和起始地址组织成二维数组</li>
<li>初始状态：只有一个大小为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> 的空闲块</li>
</ul>
</li>
<li>分配过程
<ul>
<li>由小到大在空闲块数组中找最小的可用空闲块</li>
<li>如空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块</li>
</ul>
</li>
<li>释放过程
<ul>
<li>把释放的块放入空闲块数组</li>
<li>合并满足合并条件的空闲块</li>
</ul>
</li>
<li>合并条件
<ul>
<li>大小相同为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></li>
<li>地址相邻</li>
<li>低地址空闲块起始地址为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord cjk_fallback mtight">＋</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 的倍数</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="non-contiguous-memory-allocation"><a class="header" href="#non-contiguous-memory-allocation">Non-contiguous Memory Allocation</a></h1>
<ul>
<li>设计目标：提高内存利用效率和管理灵活性</li>
<li>优点
<ul>
<li>允许一个程序的使用非连续的物理地址空间</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
</li>
</ul>
<h2 id="segmentation"><a class="header" href="#segmentation">Segmentation</a></h2>
<h3 id="segmented-address-space"><a class="header" href="#segmented-address-space">Segmented Address Space</a></h3>
<p>进程的段地址空间由多个段组成：主代码段、子模块代码段、公用库代码段、堆栈段（stack）、堆数据（heap）、初始化数据段和符号表等。<br />
段式存储管理的目的在于<strong>更细粒度和灵活的分离与共享</strong>。</p>
<h3 id="access-mechanisms"><a class="header" href="#access-mechanisms">Access Mechanisms</a></h3>
<ul>
<li>
<p>段的概念</p>
<ul>
<li>段表示访问方式和储存数据等属性相同的一段地址空间。</li>
<li>对应一个连续的内存块</li>
<li>若干个段组成逻辑地址空间</li>
</ul>
</li>
<li>
<p>段访问： 逻辑地址由段基址+段内偏移组成的二元组<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">s</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">a</span><span class="mord mathrm">d</span><span class="mord mathrm">d</span><span class="mord mathrm">r</span></span><span class="mclose">)</span></span></span></span>构成</p>
</li>
</ul>
<h2 id="paging"><a class="header" href="#paging">Paging</a></h2>
<ul>
<li>Frame: 把物理地址空间划分为大小相同的基本分配单位（2 的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次方）</li>
<li>Page: 把逻辑地址空间也划分为相同大小的基本分配单位</li>
<li>Frame 和 Page 的大小必须是相同的</li>
</ul>
<h3 id="frame"><a class="header" href="#frame">Frame</a></h3>
<p>物理内存被划分为相同大小的帧，用二元组 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">o</span><span class="mclose">)</span></span></span></span> 表示，其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 代表帧号（共有 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span> 个帧），每个帧有 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span> 个字节。因此物理地址计算公式为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span></p>
<h3 id="page"><a class="header" href="#page">Page</a></h3>
<p>进程逻辑地址空间被划分为大小相等的页，通常来讲，页内偏移等于段内偏移但页号不等于帧号。逻辑地址由二元组 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">o</span><span class="mclose">)</span></span></span></span> 表示，虚拟地址计算公式为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span></p>
<h3 id="address-mapping"><a class="header" href="#address-mapping">Address Mapping</a></h3>
<ul>
<li>逻辑地址中的页号是连续的</li>
<li>物理地址中的帧号不是连续的</li>
<li><strong>不是</strong>所有的页都有相应的帧对应</li>
</ul>
<h3 id="page-tables"><a class="header" href="#page-tables">Page Tables</a></h3>
<p>Page tables save the information of the mapping from logical addresses to physical addresses.</p>
<p>每一个进程都有一个页表，每一个页面对应一个页表项，通过 Page Table Base Register (PTBR) 实现页面到页表项之间的映射。</p>
<h4 id="page-table-entries"><a class="header" href="#page-table-entries">Page Table Entries</a></h4>
<p><img src="memory_management/./assets/page_table_entry_information.png" alt="Page Table Entry Information" /></p>
<ul>
<li>
<p>Frame Number: It gives the frame number in which the current page you are looking for is present. The number of bits required depends on the number of frames.Frame bit is also known as <strong>address translation bit</strong>.</p>
</li>
<li>
<p>Present/Absent Bit: Present or absent bit says whether a particular page you are looking for is present or absent. In case if it is not present, that is called <strong>Page Faults</strong>. It is set to 0 if the corresponding page is not in memory. Used to control page faults by the operating system to support virtual memory. Sometimes this bit is also known as <strong>valid/invalid bits</strong>.</p>
</li>
<li>
<p>Protection Bit: Protection bit says that what kind of protection you want on that page. So, these bit for the protection of the page frame (read, write etc).</p>
</li>
<li>
<p>Referenced bit: Referenced bit will say whether this page has been referred in the last clock cycle or not. It is set to 1 by hardware when the page is accessed.</p>
</li>
<li>
<p>Modified Bit: Modified bit says whether the page has been modified or not. Modified means sometimes you might try to write something on to the page. If a page is modified, then whenever you should replace that page with some other page, then the modified information should be kept on the hard disk or it has to be written back or it has to be saved back. It is set to 1 by hardware on write-access to page. Sometimes this modified bit is also called as the <strong>Dirty bit</strong>.</p>
</li>
<li>
<p>Caching Enable/Disabled: a bit <strong>enables</strong> or <strong>disable</strong> caching of the page.</p>
</li>
</ul>
<h3 id="performance-problem"><a class="header" href="#performance-problem">Performance Problem</a></h3>
<ol>
<li>访问一个内存单元需要先访问页表，再访问数据。</li>
<li>页表可能会非常大</li>
</ol>
<p>How to solve: Caching or Indirection</p>
<h2 id="translation-lookaside-buffer"><a class="header" href="#translation-lookaside-buffer">Translation Lookaside Buffer</a></h2>
<p>Translation lookaside buffer (TLB) functions in the same way as a memory cache and contains those page table entries that have been most recently used. The organization of the resulting paging hardware is illustrated in Figure below. Given a virtual address, the processor will first examine the TLB. If the desired page table entry is present (TLB hit), then the frame number is retrieved and the real address is formed. If the desired page table entry is not found (TLB miss), then the processor uses the page number to index the process page table and examine the corresponding page table entry. If the “present bit” is set, then the page is in main memory, and the processor can retrieve the frame number from the page table entry to form the real address. The processor also updates the TLB to include this new page table entry. Finally, if the present bit is not set, then the desired page is not in main memory and a memory access fault, called a page fault, is issued.</p>
<p><img src="memory_management/./assets/use_of_a_tlb.png" alt="Use of a Translation Lookaside Buffer" /></p>
<h3 id="hierarchical-page-table"><a class="header" href="#hierarchical-page-table">Hierarchical Page Table</a></h3>
<p>Take a two-level hierarchical page table as an example:</p>
<p><img src="memory_management/./assets/a_two_level_hierarchical_page_table.png" alt="A Two-Level Hierarchical Page Table" /></p>
<p><img src="memory_management/./assets/address_translation_in_a_hierarchical_paging_system.png" alt="Address Translation in a Two-Level Paging System" /></p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="virtual-memory"><a class="header" href="#virtual-memory">Virtual Memory</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="preliminary-concepts"><a class="header" href="#preliminary-concepts">Preliminary Concepts</a></h1>
<h2 id="overlay"><a class="header" href="#overlay">Overlay</a></h2>
<ul>
<li>
<p>解释：应用程序<strong>手动</strong>把需要的指令和数据保存在内存中</p>
</li>
<li>
<p>目标：在较小的可用内存中运行较大的程序</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>只能发生在没有调用关系的模块间</li>
<li><strong>程序员</strong>必须给出模块间的逻辑覆盖结构</li>
<li>发生在运行程序的内部模块间</li>
</ul>
</li>
<li>
<p>方法：根据程序逻辑结构，将程序划分为若干<strong>功能相对独立的模块</strong>，将不会同时执行的模块<strong>共享同一块内存区域</strong>。</p>
<ul>
<li>必要部分（常用功能）的代码和数据常驻内存</li>
<li>可选部分（不常用功能）放在其他程序模块中，只在需要用到的时候装入内存</li>
<li>不存在调用关系模块可共享一块内存区域</li>
</ul>
</li>
<li>
<p>示例<br />
<img src="virtual_memory/./../memory_management/assets/overlay_example.png" alt="An Overlay Example" /></p>
</li>
<li>
<p>不足</p>
<ul>
<li>增加编程困难
<ul>
<li>需要划分功能模块并确定模块间的覆盖关系</li>
<li>增加了编程的复杂度</li>
</ul>
</li>
<li>增加执行时间
<ul>
<li>从外存装入覆盖模块</li>
<li>时间换空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="swapping"><a class="header" href="#swapping">Swapping</a></h2>
<ul>
<li>目标：增加正在运行或需要运行的程序的内存</li>
<li>特点：
<ul>
<li>以进程为单位</li>
<li>不需要模块间的逻辑覆盖结构</li>
<li>发生在内存进程间</li>
</ul>
</li>
<li>实现方法：
<ul>
<li>可将暂时不能运行的程序放到外存</li>
<li>换入换出的基本单位：整个进程的地址空间</li>
<li>换出 (swap out)：把一个进程的整个地址空间保存到外存</li>
<li>换入 (swap in)：将外存中某进程的地址空间读入到内存</li>
</ul>
</li>
<li>问题与解答
<ul>
<li>何时需要交换：当内存空间不够或又不够的可能时换出</li>
<li>交换区大小：存放所有用户进程的所有内存映像的拷贝</li>
<li>换出后再换入时要放在原处吗（重定位问题）：采用动态地址映射的方法</li>
</ul>
</li>
</ul>
<h2 id="the-principle-of-locality"><a class="header" href="#the-principle-of-locality">The Principle of Locality</a></h2>
<p>Intuitively, the principle of locality makes sense. Consider the following line of
reasoning:</p>
<ol>
<li>
<p>Except for <strong>branch and call instructions</strong>, which constitute only a small fraction
of all program instructions, program execution is sequential. Hence, in most
cases, the next instruction to be fetched immediately follows the last instruction
fetched.</p>
</li>
<li>
<p>It is rare to have a long uninterrupted sequence of procedure calls followed by
the corresponding sequence of returns. Rather, a program remains confined to a
rather narrow window of procedure-invocation depth. Thus, over a short period
of time, references to instructions tend to <strong>be localized to a few procedures</strong>.</p>
</li>
<li>
<p>Most iterative constructs consist of <strong>a relatively small number of instructions repeated many times</strong>. For the duration of the iteration, computation is therefore
confined to a small contiguous portion of a program.</p>
</li>
<li>
<p>In many programs, much of the computation involves processing data structures, such as arrays or sequences of records. In many cases, <strong>successive references to these data structures</strong> will be to closely located data items.</p>
</li>
</ol>
<p>To summarize, the principle of locality states that program and data references within a process tend to cluster. Hence, the assumption that only a few pieces of a process will be needed over a short period of time is valid. Also, it should be possible to make intelligent guesses about which pieces of a process will be needed in the near future, which avoids thrashing.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-c++">for (int j = 0; j &lt; 1024; j++)
  for (int i = 0; i &lt; 1024; i++) A[i][j] = 0;

for (int i = 0; i &lt; 1024; i++)
  for (int j = 0; j &lt; 1024; j++) A[i][j] = 0;
</code></pre>
<p>In the first code, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span> page faults occur, and in the second code, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span> page faults occur.</p>
<h2 id="virtual-storage"><a class="header" href="#virtual-storage">Virtual Storage</a></h2>
<ul>
<li>
<p>思路</p>
<ul>
<li>把不常用的部分内存块暂存到外</li>
</ul>
</li>
<li>
<p>原理</p>
<ul>
<li>装载程序时
<ul>
<li>只将当前指令执行需要的部分页面或段载入内存</li>
</ul>
</li>
<li>指令执行中需要的指令或数据不在内存（即缺页或缺段）时
<ul>
<li>处理器通知操作系统将相应的页或段调入内存</li>
</ul>
</li>
<li>操作系统将内存中暂时不用的页或段保存到外存</li>
</ul>
</li>
<li>
<p>实现方式</p>
<ul>
<li>虚拟页式存储</li>
<li>虚拟段式存储</li>
</ul>
</li>
<li>
<p>基本特征</p>
<ul>
<li>不连续性
<ul>
<li>物理内存分配非连续</li>
<li>虚拟地址空间使用非连续</li>
</ul>
</li>
<li>大用户空间
<ul>
<li>提供给用户的虚拟内存可大于实际的物理内存</li>
</ul>
</li>
<li>部分交换
<ul>
<li>虚拟存储只对部分虚拟地址空间进行调入和调出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="virtual-pages"><a class="header" href="#virtual-pages">Virtual Pages</a></h2>
<p>在<a href="virtual_memory/../memory_management/noncontiguous_memory_allocation.html#paging">页式存储管理</a>的增加请求掉和和页面替换</p>
<ul>
<li>当用户程序装载到内存运行时，只装入部分页面就启动程序运行</li>
<li>进程在运行中发现有需要的代码或数据不在内存中就向系统发出缺页异常请求</li>
<li>操作系统在处理缺页异常时，将外存中的相应页面载入内存使得进程能继续执行
<img src="virtual_memory/./assets/address_translation_in_virtual_pages.png" alt="Address Translation in Virtual Pages" /></li>
</ul>
<h3 id="a-hrefvirtual_memorymemory_managementnoncontiguous_memory_allocationhtmlpage-table-entriespage-table-entriesa"><a class="header" href="#a-hrefvirtual_memorymemory_managementnoncontiguous_memory_allocationhtmlpage-table-entriespage-table-entriesa"><a href="virtual_memory/../memory_management/noncontiguous_memory_allocation.html#page-table-entries">Page Table Entries</a></a></h3>
<h2 id="page-faults"><a class="header" href="#page-faults">Page Faults</a></h2>
<h3 id="procedures-1"><a class="header" href="#procedures-1">Procedures</a></h3>
<ol>
<li>在内存中有空闲物理帧时，分配一物理帧 f，转第 5 步</li>
<li>根据页面替换算法选择将被替换的物理帧对应的逻辑页 q</li>
<li>若 q 被修改过则将它写回内存</li>
<li>修改 q 的 present bit 为 0</li>
<li>将需要访问的页 p 载入物理帧 f</li>
<li>修改 p 的 present bit 为 1，帧号为 f</li>
<li>重新执行产生缺页的指令</li>
</ol>
<h3 id="effective-memory-access-time"><a class="header" href="#effective-memory-access-time">Effective Memory-access Time</a></h3>
<ul>
<li>
<p>Hit Ratio: The percentage of times that a particular page number is found in the TLB.</p>
</li>
<li>
<p>TLB Hit: The page is found in TLB</p>
</li>
<li>
<p>TLB Miss: The page is not found in the TLB so that accessing memory to get the page table entries and the data is needed.</p>
</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">E</span><span class="mord mathrm">A</span><span class="mord mathrm">T</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">L</span><span class="mord mathrm">B</span><span class="mspace"> </span><span class="mord mathrm">m</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">s</span><span class="mspace"> </span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm">h</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mspace"> </span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">o</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">L</span><span class="mord mathrm">B</span><span class="mspace"> </span><span class="mord mathrm">h</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mspace"> </span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm">h</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mspace"> </span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">o</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">L</span><span class="mord mathrm">B</span><span class="mspace"> </span><span class="mord mathrm">s</span><span class="mord mathrm">e</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">c</span><span class="mord mathrm">h</span><span class="mspace"> </span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">y</span><span class="mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">c</span><span class="mord mathrm">c</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">s</span><span class="mspace"> </span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm">h</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mspace"> </span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">o</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">L</span><span class="mord mathrm">B</span><span class="mspace"> </span><span class="mord mathrm">s</span><span class="mord mathrm">e</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">c</span><span class="mord mathrm">h</span><span class="mspace"> </span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">y</span><span class="mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">c</span><span class="mord mathrm">c</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">s</span><span class="mspace"> </span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm">h</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mspace"> </span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<ul>
<li>TLB lookup takes 5 nano sec.</li>
<li>Memory access time is 100 nano sec.</li>
<li>Hit ratio is 80%.</li>
</ul>
<p>What is the effective memory access time?
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">E</span><span class="mord mathrm">A</span><span class="mord mathrm">T</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mord"><span class="mspace"> </span><span class="mord mathrm">n</span><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">o</span><span class="mspace"> </span><span class="mord mathrm">s</span><span class="mord mathrm">e</span><span class="mord mathrm">c</span></span></span></span></span></span></p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="local-replacement"><a class="header" href="#local-replacement">Local Replacement</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<ul>
<li>置换算法实现的功能：当出现缺页异常，需调入新页面而内存已满时，置换算法<strong>选择被置换的物理页面</strong></li>
<li>设计目标
<ul>
<li>尽可能<strong>减少页面调入调出的次数</strong></li>
<li>把短期内不再访问的页面调出</li>
</ul>
</li>
<li>页面锁定 (frame locking)
<ul>
<li>描述必须常驻内存的逻辑页面</li>
<li>操作系统的关键部分</li>
<li>要求响应速度的代码和数据</li>
<li>页表中的锁定标志位 (lock bit)</li>
</ul>
</li>
<li>评价方法
<ul>
<li>模拟页面置换行为，记录产生缺页的次数</li>
<li>更少的缺页次数，更好的性能</li>
</ul>
</li>
</ul>
<h2 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h2>
<h3 id="optimal-opt"><a class="header" href="#optimal-opt">Optimal (OPT)</a></h3>
<ul>
<li>Selects for replacement that page for which <strong>the time to the next reference is the longest</strong> (based on future information), and results in the fewest number of page faults.</li>
<li>Impossible to implement</li>
<li>Benchmark algorithm (a standard to judge real-world
algorithms)</li>
</ul>
<h3 id="least-recently-used-lru"><a class="header" href="#least-recently-used-lru">Least recently used (LRU)</a></h3>
<ul>
<li>Replaces the page in memory that <strong>has not been referenced for the long time</strong> (based on past information). By the principle of locality, this should be the page least likely to be referenced in the near future.</li>
<li>Does nearly as well as the optimal policy.</li>
<li>Implement by linked list or stack, ordered by visit time, with high time complexity.</li>
<li>LRU can be degenerated into FIFO if a block have not been referenced since it was fetched into memory.</li>
</ul>
<h3 id="first-in-first-out-fifo"><a class="header" href="#first-in-first-out-fifo">First-in-first-out (FIFO)</a></h3>
<ul>
<li><strong>Replacing the page that has been in memory the longest</strong>: A page fetched into memory a long time ago may have now fallen out of use</li>
<li>Process as a circular buffer</li>
<li>May cause <em>belady anomaly</em></li>
<li>Easy to implement but performs poorly (<a href="virtual_memory/local_replacement.html#belady-anomaly">Belady Anomaly</a>)</li>
</ul>
<h3 id="clock"><a class="header" href="#clock">Clock</a></h3>
<ul>
<li>Organize frames in a circular buffer with which a pointer is associated.</li>
<li>First loaded or subsequently referenced, use bit = 1.</li>
<li>When replace, find a frame with use bit = 0, and reset use bit of frames that each scan encounters to 0.</li>
<li>If all of the frames have a use bit of 1, then the pointer will make one complete cycle through the buffer, setting all the use bits to 0, and stop at its original position, replacing the page in that frame.</li>
<li>An implementation of LRU using FIFO mechanism.</li>
</ul>
<h3 id="improved-clock"><a class="header" href="#improved-clock">Improved Clock</a></h3>
<p>The clock algorithm can be made more powerful by increasing the number of bits that it employs like</p>
<ol>
<li>Not accessed recently, not modified (u = 0; m = 0)</li>
<li>Accessed recently, not modified (u = 1; m = 0)</li>
<li>Not accessed recently, modified (u = 0; m = 1)</li>
<li>Accessed recently, modified (u = 1; m = 1)</li>
</ol>
<ul>
<li>Beginning at the current position of the pointer, scan the frame buffer. During
this scan, <strong>make no changes to the use bit</strong>. The first frame encountered with
(u = 0; m = 0) is selected for replacement.</li>
<li>If step 1 fails, scan again, looking for the frame with (u = 0; m = 1). The first
such frame encountered is selected for replacement. During this scan, <strong>set the
use bit to 0 on each frame that is bypassed</strong>.</li>
<li>If step 2 fails, the pointer should have returned to its original position and all
of the frames in the set will have a use bit of 0. Repeat step 1 and, if necessary,
step 2. This time, a frame will be found for the replacement.</li>
</ul>
<h3 id="least-frequently-used"><a class="header" href="#least-frequently-used">Least Frequently Used</a></h3>
<ul>
<li>Replace the block in the set that has <strong>experienced the fewest references</strong>.</li>
<li>could be implemented by associating a counter with each block.</li>
<li>When a block is brought in, it is assigned a count of 1; with each reference to the block, its count is incremented by 1. When replacement is required, <strong>the block with the smallest count is selected</strong>.</li>
<li>Make poor replacement choices when certain blocks are referenced relatively infrequently overall, but frequently in some short intervals of repeated references due to locality, thus building up high reference counts.</li>
</ul>
<h4 id="fbr"><a class="header" href="#fbr">FBR</a></h4>
<ul>
<li>To overcome this difficulty with LFU, a technique known as <strong>frequency-based replacement</strong> is proposed.
<ul>
<li>A simple version in the Figure (a): The blocks are organized in a stack and the top part of the stack is designated for the new section, which means the referenced block is moved to the top of the new section if there is a cache hit. Besides, if the block is not in the new section (i.e. the old section), its reference count increments by 1.</li>
<li>A further refinement addresses this problem, seeing Figure (b): Divide the stack into three sections (new, middle and old). As before, reference counts are not incremented on blocks in the new section. However, only blocks in the old section are eligible for replacement. Supposing a sufficiently large middle section, this allows relatively frequently referenced blocks a chance to build uo their counts before becoming eligible for replacement (buffer section). Simulation studies indicates that this refined policy is significantly better than LRU or LFU. Note that sizes of new, middle and old sections are hyperparameters which should be fine tuned in daily use.</li>
</ul>
</li>
</ul>
<div align="center">
<p><img src="virtual_memory/./assets/frequency_based_replacement.png" alt="Frequency-Based Replacement" /></p>
</div>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<h4 id="optlrufifoclock"><a class="header" href="#optlrufifoclock">OPT/LRU/FIFO/CLOCK</a></h4>
<p><img src="virtual_memory/./assets/algorithm_compare.png" alt="Algorithm Compare" /></p>
<h4 id="improved-clock-1"><a class="header" href="#improved-clock-1">Improved Clock</a></h4>
<center>
<table><thead><tr><th align="center">Time</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th></tr></thead><tbody>
<tr><td align="center">Request</td><td align="center"></td><td align="center">c</td><td align="center">a<sup>w</sup></td><td align="center">d</td><td align="center">b<sup>w</sup></td><td align="center">e</td><td align="center">b</td><td align="center">a<sup>w</sup></td><td align="center">b</td><td align="center">c</td><td align="center">d</td></tr>
<tr><td align="center">Frame 0 (u,m)</td><td align="center"><em>a(00)</em></td><td align="center"><em>a(00)</em></td><td align="center"><em><strong>a(11)</strong></em></td><td align="center"><em>a(11)</em></td><td align="center"><em>a(11)</em></td><td align="center">a(01)</td><td align="center">a(01)</td><td align="center"><strong>a(11)</strong></td><td align="center">a(11)</td><td align="center"><em>a(11)</em></td><td align="center">a(01)</td></tr>
<tr><td align="center">Frame 1 (u,m)</td><td align="center">b(00)</td><td align="center">b(00)</td><td align="center">b(00)</td><td align="center">b(00)</td><td align="center"><strong>b(11)</strong></td><td align="center">b(01)</td><td align="center"><strong>b(11)</strong></td><td align="center">b(11)</td><td align="center"><strong>b(11)</strong></td><td align="center">b(11)</td><td align="center">b(01)</td></tr>
<tr><td align="center">Frame 2 (u,m)</td><td align="center">c(00)</td><td align="center"><strong>c(10)</strong></td><td align="center">c(10)</td><td align="center">c(10)</td><td align="center">c(10)</td><td align="center"><strong>e(10)</strong></td><td align="center">e(10)</td><td align="center">e(10)</td><td align="center">e(10)</td><td align="center">e(10)</td><td align="center"><strong>d(10)</strong></td></tr>
<tr><td align="center">Frame 3 (u,m)</td><td align="center">d(00)</td><td align="center">d(00)</td><td align="center">d(00)</td><td align="center"><strong>d(10)</strong></td><td align="center">d(10)</td><td align="center"><em>d(00)</em></td><td align="center"><em>d(00)</em></td><td align="center"><em>d(00)</em></td><td align="center"><em>d(00)</em></td><td align="center"><strong>c(10)</strong></td><td align="center"><em>c(00)</em></td></tr>
<tr><td align="center">Page Fault</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center">√</td></tr>
</tbody></table>
</center>
<h4 id="lfu"><a class="header" href="#lfu">LFU</a></h4>
<p>Notice that a<sup>x</sup> means a has been referenced for x times.</p>
<center>
<table><thead><tr><th align="center">Time</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th></tr></thead><tbody>
<tr><td align="center">Request</td><td align="center"></td><td align="center">c<sup>7</sup></td><td align="center">a<sup>1</sup></td><td align="center">d<sup>14</sup></td><td align="center">b<sup>5</sup></td><td align="center">e<sup>18</sup></td><td align="center">b<sup>1</sup></td><td align="center">a<sup>19</sup></td><td align="center">b<sup>20</sup></td><td align="center">c<sup>20</sup></td><td align="center">d<sup>17</sup></td></tr>
<tr><td align="center">Frame 0</td><td align="center">a<sup>8</sup></td><td align="center">a<sup>8</sup></td><td align="center"><strong>a<sup>9</sup></strong></td><td align="center">a<sup>9</sup></td><td align="center">a<sup>9</sup></td><td align="center"><strong>e<sup>18</sup></strong></td><td align="center">e<sup>18</sup></td><td align="center">e<sup>18</sup></td><td align="center">e<sup>18</sup></td><td align="center">e<sup>18</sup></td><td align="center"><strong>d<sup>17</sup></strong></td></tr>
<tr><td align="center">Frame 1</td><td align="center">b<sup>5</sup></td><td align="center">b<sup>5</sup></td><td align="center">b<sup>5</sup></td><td align="center">b<sup>5</sup></td><td align="center"><strong>b<sup>10</sup></strong></td><td align="center">b<sup>10</sup></td><td align="center"><strong>b<sup>11</sup></strong></td><td align="center"><strong>a<sup>19</sup></strong></td><td align="center">a<sup>19</sup></td><td align="center">a<sup>19</sup></td><td align="center">a<sup>19</sup></td></tr>
<tr><td align="center">Frame 2</td><td align="center">c<sup>6</sup></td><td align="center"><strong>c<sup>13</sup></strong></td><td align="center">c<sup>13</sup></td><td align="center">c<sup>13</sup></td><td align="center">c<sup>13</sup></td><td align="center">c<sup>13</sup></td><td align="center">c<sup>13</sup></td><td align="center">c<sup>13</sup></td><td align="center"><strong>b<sup>20</sup></strong></td><td align="center">b<sup>20</sup></td><td align="center">b<sup>20</sup></td></tr>
<tr><td align="center">Frame 3</td><td align="center">d<sup>2</sup></td><td align="center">d<sup>2</sup></td><td align="center">d<sup>2</sup></td><td align="center"><strong>d<sup>16</sup></strong></td><td align="center">d<sup>16</sup></td><td align="center">d<sup>16</sup></td><td align="center">d<sup>16</sup></td><td align="center">d<sup>16</sup></td><td align="center">d<sup>16</sup></td><td align="center"><strong>c<sup>20</sup></strong></td><td align="center">c<sup>20</sup></td></tr>
<tr><td align="center">Page Fault</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr>
</tbody></table>
</center>
<h2 id="belady-anomaly"><a class="header" href="#belady-anomaly">Belady Anomaly</a></h2>
<p>Belady anomaly is the phenomenon in which <strong>increasing the number of page frames</strong> results in <strong>an increase in the number of page faults</strong> for certain memory access patterns. This phenomenon is commonly experienced when using the first-in first-out (FIFO) page replacement algorithm.</p>
<p>In <strong>FIFO</strong>, the page fault <strong>may or may not increase</strong> as the page frames increase, but in <strong>Optimal and stack-based algorithms like LRU</strong>, as the page frames increase the page fault <strong>decreases</strong>.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="global-replacement"><a class="header" href="#global-replacement">Global Replacement</a></h1>
<p>A global replacement policy considers <strong>all unlocked pages</strong> in main memory as candidates for replacement, regardless of which process owns a particular page.</p>
<ul>
<li>
<p>全局置换算法要解决的问题</p>
<ul>
<li>进程在不同阶段的内存需求是变化的</li>
<li>分配给进程的内存也需要在不同阶段有所变化</li>
<li>全局置换算法需要确定分配给进程的物理页面数</li>
</ul>
</li>
<li>
<p>CPU 利用率与并发进程数的关系</p>
<ul>
<li>进程数少时，提高并发进程数可提高 CPU 利用率</li>
<li>并发进程导致内存访问增加</li>
<li>并发进程的内存访问降低了访存的局部性特征</li>
<li>局部性特征的下降会导致缺页率上升和 CPU 利用率下降</li>
</ul>
</li>
</ul>
<h2 id="working-set-strategy"><a class="header" href="#working-set-strategy">Working Set Strategy</a></h2>
<h3 id="working-set"><a class="header" href="#working-set">Working Set</a></h3>
<p>The working set with parameter <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> for a process at virtual time <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>, which we designate as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span></span></span></span>, is <strong>the set of pages of that process that have been referenced in the last <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> virtual time units</strong>.<strong>The variable <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> is a window of
virtual time over which the process is observed</strong>. （当前时刻 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 前的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 时间窗口中的所有访问页面所组成的集合）</p>
<p>The working set size will be a non-decreasing function of the window size. The result is illustrated in Figure below, which shows a sequence of page references for a process.</p>
<p><img src="virtual_memory/./assets/working_set_defined_by_window_size.png" alt="Working Set Defined by Window Size" /></p>
<p>Note that the larger the window size, the larger is the working set, which can be expressed in the following
relationship:
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">W</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊇</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">W</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span></span></span></span></span>
The working set is also a function of time. If a process executes over <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> time units and uses only a single page, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. A working set can also grow as large as the number of pages N of the process, if many different pages are rapidly
addressed and if the window size allows. Thus,
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">W</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">Δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<p><img src="virtual_memory/./assets/typical_graph_of_working_set_size.png" alt="Typical Graph of Working Set Size" /></p>
<p>Figure above indicates the way in which the working set size can vary over time for a fixed value of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>. For many programs, periods of relatively stable working set sizes alternate with periods of rapid change.</p>
<ul>
<li>When a process first begins executing, it gradually builds up to a working set as it references new pages.</li>
<li>Eventually by the principle of locality, the process should stabilize on a certain set of pages.</li>
<li>Subsequent transient periods reflect a shift of the program to a new locality.</li>
<li>During the transition phase, <strong>some of the pages from the old locality remain with the window, causing a surge in the size of the working as new pages are referenced</strong>.</li>
<li>As the window slides past these page references, the working set size declines until it contains only those pages from the new locality.</li>
</ul>
<h3 id="resident-set"><a class="header" href="#resident-set">Resident Set</a></h3>
<p>That portion of a process that is <strong>actually in main memory</strong> at a given
time. （在当前时刻，进程实际驻留在内存当中的页面集合）</p>
<ul>
<li>Resident Set 和 Working Set  的关系
<ul>
<li>Working Set 是进程在运行过程中<strong>固有性质</strong></li>
<li>Resident Set 取决于系统分配给进程物理页面的数目和页面置换算法</li>
</ul>
</li>
<li>Resident Set 与 <a href="virtual_memory/global_replacement.html#page-fault-rate-pfr">Page Fault Rate</a> 的关系
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathrm">R</span><span class="mord mathrm">e</span><span class="mord mathrm">s</span><span class="mord mathrm">i</span><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mspace"> </span><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊇</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">W</span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mathrm">k</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace"> </span><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span></span></span></span>，缺页较少</li>
<li>Working Set 发生剧烈抖动时，缺页较多</li>
<li>进程 Resident Set 大小达到一定数目后，PFF 不会显著下降</li>
</ul>
</li>
</ul>
<h3 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h3>
<h4 id="basic-idea"><a class="header" href="#basic-idea">Basic Idea</a></h4>
<ol>
<li>Monitor the working set of each process.</li>
<li>Periodically remove from the resident set of a process those pages that are not in its working set. This is essentially an LRU policy.</li>
<li>A process may execute only if its working set is in main memory (i.e., if its
resident set includes its working set).</li>
</ol>
<h4 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h4>
<ul>
<li>窗口大小<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>：当前时刻前 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span> 个访问页面</li>
<li>访存链表
<ul>
<li>访存时，换出不在工作集的页面，更新访存链表</li>
<li>缺页时，换入页面，更新访存链表</li>
</ul>
</li>
</ul>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>
<img src="virtual_memory/./assets/working_set_algorithm_example.png" alt="Working Set Algorithm Example" /></p>
<h2 id="page-fault-frequency-strategy"><a class="header" href="#page-fault-frequency-strategy">Page Fault Frequency Strategy</a></h2>
<h3 id="page-fault-rate-pfr"><a class="header" href="#page-fault-rate-pfr">Page Fault Rate (PFR)</a></h3>
<p>The reciprocal of time between page faults is the page fault rate.</p>
<ul>
<li>影响 PFR 的因素
<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页面数目</li>
<li>页面大小</li>
<li>程序写法</li>
</ul>
</li>
</ul>
<h3 id="algorithm-1"><a class="header" href="#algorithm-1">Algorithm</a></h3>
<h4 id="basic-idea-1"><a class="header" href="#basic-idea-1">Basic Idea</a></h4>
<ul>
<li>It requires <strong>a use bit</strong> to be associated with each page in memory. <strong>The bit is set to 1 when that page is accessed</strong>. When a page fault occurs, the OS notes the virtual time since the last page fault for that process; this could be done by maintaining a counter of page references.</li>
<li>A threshold F is defined. If <strong>the amount of time since the last page fault is less than F</strong>, <strong>then a page is added to the resident set</strong> of the process.</li>
<li>Otherwise, <strong>discard all pages with a use bit of 0, and shrink the resident set accordingly</strong>. At the same time, <em>reset the use bit on the remaining pages of the process to 0</em>.</li>
</ul>
<h4 id="example-4"><a class="header" href="#example-4">Example</a></h4>
<p>The threshold F=2
<img src="virtual_memory/./assets/pfr_example.png" alt="PBR Example" /></p>
<h2 id="thrashing"><a class="header" href="#thrashing">Thrashing</a></h2>
<p>A phenomenon in virtual memory schemes, in which the processor <strong>spends most of its time swapping pieces rather than executing instructions</strong>.</p>
<ul>
<li>产生原因：随着驻留内存进程数的增加，由于页面数有限，导致缺页现象频繁发生。</li>
<li>操作系统需要在并发水平和缺页率间达到一个平衡，即选择一个适当进程数目和进程需要的页面数</li>
</ul>
<h2 id="a-hrefvirtual_memorylocal_replacementhtmlfbrfbra"><a class="header" href="#a-hrefvirtual_memorylocal_replacementhtmlfbrfbra"><a href="virtual_memory/./local_replacement.html#fbr">FBR</a></a></h2>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="processes-and-threads"><a class="header" href="#processes-and-threads">Processes and Threads</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="processes"><a class="header" href="#processes">Processes</a></h1>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器：CR0, IP</li>
<li>通用寄存器：AX, BX, CX</li>
<li>进程占用系统资源</li>
</ul>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<ul>
<li>动态性：可动态地创建、结束进程</li>
<li>并发性：进程可以被独立调度并占用处理机运行</li>
<li>独立性：不同进程的工作不相互影响</li>
<li>制约性：因访问共享数据/资源或进程间同步而产生制约</li>
</ul>
<h3 id="relations-and-discrepancies-between-programs"><a class="header" href="#relations-and-discrepancies-between-programs">Relations and Discrepancies between programs</a></h3>
<h4 id="relations"><a class="header" href="#relations">Relations</a></h4>
<ul>
<li>Processes are the abstract of Programs in executive states
<ul>
<li>Program = Static executive file</li>
<li>Process = Program + executive states</li>
</ul>
</li>
<li>Multiple executions of the some program are regarded as different processes.</li>
<li>Necessary resources in executing processes: Memory and CPU</li>
</ul>
<h4 id="discrepancies"><a class="header" href="#discrepancies">Discrepancies</a></h4>
<ul>
<li>进程时动态的，程序时静态的
<ul>
<li>程序是有序代码的集合</li>
<li>进程是程序的执行</li>
</ul>
</li>
<li>进程是暂时的，程序时永久的
<ul>
<li>进程是一个状态变化的过程</li>
<li>程序可长久保存</li>
</ul>
</li>
<li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块</li>
</ul>
<h2 id="process-control-block"><a class="header" href="#process-control-block">Process Control Block</a></h2>
<p>操作系统用 PCB 来进程的基本状态，每个进程都在操作系统中有一个唯一对应的PCB</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<p>At any given point in time, while the program is executing, this process can be uniquely characterized by a number of elements, including the following:</p>
<ul>
<li>Identifier: A unique identifier associated with this process, to distinguish it from all other processes.</li>
<li>State: If the process is currently executing, it is in the running state.</li>
<li>Priority: Priority level relative to other processes.</li>
<li>Program counter: The address of the <em>next instruction</em> in the program to be executed.</li>
<li>Memory pointers: Include pointers to the program code and data associated
with this process, plus any memory blocks shared with other processes.</li>
<li>Context data: These are data that are present in registers in the processor while the process is executing.</li>
<li>I/O status information: Includes outstanding I/O requests, I/O devices assigned to this process, a list of files in use by the process, and so on.</li>
<li>Accounting information: May include the amount of processor time and clock time used, time limits, account numbers, and so on.
<img src="processes_and_threads/./assets/simplified_process_control_block.png" alt="Simplified Process Control Block" /></li>
</ul>
<h3 id="control-information"><a class="header" href="#control-information">Control Information</a></h3>
<ul>
<li>
<p>调度和状态信息： 调度进程和处理及使用情况</p>
</li>
<li>
<p>进程间通信信息： 进程间通信相关的各种标识</p>
</li>
<li>
<p>储存管理信息</p>
</li>
<li>
<p>进程所用资源</p>
</li>
<li>
<p>有关数据结构的连接信息</p>
</li>
</ul>
<h3 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h3>
<ul>
<li>链表：同一状态进程的 PCB 组成链表</li>
<li>索引表：统一状态进程的 PCB 被同一索引指向</li>
</ul>
<h2 id="process-states"><a class="header" href="#process-states">Process States</a></h2>
<h3 id="life-cycle"><a class="header" href="#life-cycle">Life-cycle</a></h3>
<ul>
<li>进程创建
<ul>
<li>系统初始化时</li>
<li>用户请求创建一个新进程</li>
<li>被其他进程调用</li>
</ul>
</li>
<li>进程执行
<ul>
<li>内核选择一个就绪进程，让其占用处理机并执行</li>
</ul>
</li>
<li>进程等待
<ul>
<li>请求并等待系统服务，无法马上完成</li>
<li>启动某种无法马上完成的操作</li>
<li>需要的资源没有达到</li>
</ul>
</li>
<li>进程抢占
<ul>
<li>被高优先级进程抢占</li>
<li>在规定时间内未完成</li>
</ul>
</li>
<li>进程唤醒
<ul>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的时间到达</li>
<li>被阻塞的进程只能被别的进程或操作系统唤醒</li>
</ul>
</li>
<li>进程结束
<ul>
<li>自愿结束
<ul>
<li>正常退出</li>
<li>错误退出</li>
</ul>
</li>
<li>非自愿结束
<ul>
<li>致命错误</li>
<li>被其他进程所杀</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>操作系统在 <strong>中断</strong> 中处理进程<br />
以 <em>Sleep()</em> 为例，创建 -&gt; 就绪 -&gt; 运行 -&gt; 等待 -&gt; 操作系统时钟中断 ...</p>
<h3 id="process-creation"><a class="header" href="#process-creation">Process Creation</a></h3>
<h3 id="processes-switching"><a class="header" href="#processes-switching">Processes Switching</a></h3>
<p><img src="processes_and_threads/./assets/processes_switching.png" alt="Processes Switching" /></p>
<h3 id="processes-termination"><a class="header" href="#processes-termination">Processes Termination</a></h3>
<h3 id="a-two-state-process-model"><a class="header" href="#a-two-state-process-model">A Two-State Process Model</a></h3>
<p><img src="processes_and_threads/./assets/two_state_process_model.png" alt="Two-state Process Model" /></p>
<h3 id="a-five-state-model"><a class="header" href="#a-five-state-model">A Five-State Model</a></h3>
<p>Split the Not Running state of the two-state process model into two states: Ready and Blocked and add two additional states for good measure, we can get a five-state model as follows:</p>
<ol>
<li>Running: The process that is currently being executed.</li>
<li>Ready: A process that is prepared to execute when given the opportunity.</li>
<li>Blocked/Waiting: A process that cannot execute until some event occurs, such as the completion of an I/O operation.</li>
<li>New: A process that has just been created but has not yet been admitted to the pool of executable processes by the OS. Typically, a new process has not yet been loaded into main memory, although its process control block has been created.</li>
<li>Exit: A process that has been released from the pool of executable processes by the OS, either because it halted or because it aborted for some reason.</li>
</ol>
<p><img src="processes_and_threads/./assets/five_state_process_model.png" alt="Five-state Process Model" /></p>
<p>Figure above indicates the types of events that lead to each state transition for a process; the possible transitions are as follows:</p>
<ul>
<li>Null -&gt; New: A new process is created to execute a program.</li>
<li>New -&gt; Ready: The OS will move a process from the New state to the <strong>Ready state</strong> when it is prepared to take on an additional process.</li>
<li>Ready -&gt; Running: When it is time to select a process to run, the OS chooses one of the processes in the Ready state.</li>
<li>Running -&gt; Exit: The currently running process is terminated by the OS if the process indicates that it has completed or if it aborts.</li>
<li>Running -&gt; Ready
<ul>
<li>The running process has reached the maximum allowable time for uninterrupted execution;</li>
<li>The OS preempted a process if there is another process with higher priority level being blocked.</li>
</ul>
</li>
<li>Running -&gt; Blocked: A process is put in the <strong>Blocked state</strong> if it requests something for which it must wait. For example, a process may request a service from OS that OS is not prepared to perform immediately or a process may initiate that must be completed before the process can continue.</li>
<li>Blocked -&gt; Ready: A process in the Blocked state is moved to the Ready state when the event for which it has been waiting occurs.</li>
<li>Ready -&gt; Exit: For clarity, this transition is not shown on the state diagram. In some systems, a parent may terminate a child process at any time. Also, if a parent terminates, all child processes associated with that parent may be terminated.</li>
<li>Blocked -&gt; Exit: The comments under the preceding item apply.</li>
</ul>
<h2 id="suspended-processes"><a class="header" href="#suspended-processes">Suspended Processes</a></h2>
<p>There are two independent concepts here: whether a process is waiting on an event (blocked or not), and whether a process has been swapped out of main memory (suspended or not). To accommodate this <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> combination, we need four states:</p>
<ol>
<li>Ready: The process is in main memory and available for execution.</li>
<li>Blocked: The process is in main memory and awaiting an event.</li>
<li>Blocked/Suspend: The process is in <strong>secondary memory</strong> and <strong>awaiting</strong> an event.</li>
<li>Ready/Suspend: The process is in <strong>secondary memory</strong> but is <strong>available</strong> for execution
as soon as it is loaded into main memory.</li>
</ol>
<p><img src="processes_and_threads/./assets/two_suspended_states.png" alt="Two Suspended States" /></p>
<p>Important new transitions are the following:</p>
<ul>
<li>Blocked -&gt; Blocked/Suspend:</li>
<li>Blocked/Suspend -&gt; Ready/Suspend:</li>
<li>Ready/Suspend -&gt; Ready:</li>
<li>Ready -&gt; Ready/Suspend:</li>
<li>Blocked/Suspend -&gt; Blocked:</li>
</ul>
<h2 id="queueing-model"><a class="header" href="#queueing-model">Queueing Model</a></h2>
<p><img src="processes_and_threads/./assets/queueing_model.png" alt="Queueing Model" /></p>
<h2 id="process-switching"><a class="header" href="#process-switching">Process Switching</a></h2>
<p>On the face of it, the function of process switching would seem to be straightforward. At some time, a running process is interrupted, and the OS assigns another process to the Running state and turns control over to that process. However, several design issues are raised.</p>
<ul>
<li>First, what events trigger a process switch?</li>
<li>Another issue is that we must recognize the distinction between mode switching and process switching.</li>
<li>Finally, what must the OS do to the various data structures under its control to achieve a process switch?</li>
</ul>
<p>When to Switch Processes:</p>
<ul>
<li>Interrupt
<ul>
<li>Clock interrupt</li>
<li>I/O interrupt</li>
<li>Memory fault</li>
</ul>
</li>
<li>Trap</li>
<li>Supervisor call</li>
</ul>
<p>进程切换的要求：</p>
<ul>
<li>切换前，保存进程上下文</li>
<li>切换后，恢复进程上下文</li>
<li>快速切换</li>
</ul>
<p>进程生命周期的信息：</p>
<ul>
<li>寄存器</li>
<li>CPU 状态</li>
<li>内存地址空间</li>
</ul>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<p>以进程 P0、进程 P1 为例：<br />
P0 执行 --&gt; 中断或系统调用 --&gt; P0 保存 --&gt; P1 恢复 --&gt; P1 执行 --&gt; 中断或系统调用 --&gt; P1 保存 --&gt; P0 恢复 --&gt; P0 执行<br />
图示：
<img src="processes_and_threads/./assets/context_switching.png" alt="Context Switch" />
在进程切换的过程中，内核为每一个进程维护了一个对应的进程控制块（PCB），内核将相同状态进程的 PCB 放在同一队列。</p>
<h3 id="instructions-in-linux"><a class="header" href="#instructions-in-linux">Instructions in Linux</a></h3>
<ul>
<li>创建进程：<code>fork</code> or <code>exec</code></li>
<li>父进程等待子进程：<code>wait</code></li>
<li>进程的有序终止：<code>exit</code></li>
<li>优先级控制：<code>nice</code></li>
<li>进程调试支持：<code>ptrace</code></li>
<li>定时：<code>sleep</code><br />
<img src="processes_and_threads/./assets/instruction_and_state.png" alt="Instruction and State" /></li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>多进程的问题：</p>
<ol>
<li>如何通信、如何共享数据</li>
<li>系统开销较大，涉及进程的创建、进程的终止等</li>
</ol>
<p>解决思路即在进程内部增加一类实体，满足以下特性：</p>
<ol>
<li>实体之间可以并发执行</li>
<li>实体之间共享相同的地址空间</li>
</ol>
<h2 id="definition-1"><a class="header" href="#definition-1">Definition</a></h2>
<p>线程是进程的一部分，描述指令流执行状态，它是进程中<strong>指令执行流</strong>的最小单位，是 <strong>CPU 调度</strong>的基本单位。
线程间的堆栈 (Heap) 资源<strong>不能共享</strong>。<br />
线程是资源调度的基本单位，即线程描述在进程资源环境中指令流的执行状态。因此同一个进程内的线程共享其资源。</p>
<h2 id="multithreading"><a class="header" href="#multithreading">Multithreading</a></h2>
<p>Multithreading refers to the ability of an OS to support <strong>multiple, concurrent</strong> paths of execution within a single process.</p>
<center>
<p><img src="processes_and_threads/./assets/multithreading.png" alt="multithreading" /></p>
</center>
<p>The left half of Figure depicts single-threaded approaches.</p>
<ul>
<li>MS-DOS is an example of an OS that supports a single-user process and a single thread.</li>
<li>Other operating systems, such as some variants of UNIX, support multiple user processes, but only support one thread per process.</li>
</ul>
<p>The right half part of Figure states two multithreaded approaches.</p>
<ul>
<li>A Java runtime environment is an example of a system of one process with multiple threads.</li>
<li>Windows, Solaris, and many modern versions of UNIX use multiple processes, each of which supports multiple threads.</li>
</ul>
<p>In a multithreaded environment, a process is defined as the <strong>unit of resource allocation</strong> and <strong>a unit of protection</strong>. The following are associated with processes:</p>
<ul>
<li>A virtual address space that holds the process image.</li>
<li>Protected access to processors, other processors, files, and I/O resources.</li>
</ul>
<p>With a process, there may be one or more threads, each with following:</p>
<ul>
<li>A thread execution state (Running, Ready, etc.)</li>
<li>A saved thread context when not running; one way to review a thread is as an independent program counter operating within a process</li>
<li>An execution stack</li>
<li>Some per-thread static storage for local variables</li>
<li>Access to the memory and resources of its process, shared with all other threads in that process.</li>
</ul>
<p>The Figure below illustrates the distinction between threads and processes from the point of view of process management.</p>
<p><img src="processes_and_threads/./assets/single_threaded_and_multithreaded_process_models.png" alt="Single Threaded and Multithreaded Process Models" /></p>
<p>The key benefits of threads derive from the performance implications:</p>
<ol>
<li>
<p>It takes <strong>far less time</strong> to create a new thread in an existing process, than to create a brand-new process.</p>
</li>
<li>
<p>It takes <strong>less time</strong> to terminate a thread than a process.</p>
</li>
<li>
<p>It takes <strong>less time</strong> to switch between two thread s within the same process than to switch between processes.</p>
</li>
<li>
<p>Threads <strong>enhance efficiency</strong> in communication between different executing programs.</p>
</li>
</ol>
<ul>
<li>多线程的优点
<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>多线程之间可以并发</li>
<li>线程间共享地址空间和文件等资源</li>
</ul>
</li>
<li>多线程的缺点
<ul>
<li>一个线程崩溃，会导致同属一个进程下的其他线程崩溃</li>
</ul>
</li>
</ul>
<h2 id="types-of-threads"><a class="header" href="#types-of-threads">Types of Threads</a></h2>
<p>There are two broad categories of thread implementation: <strong>user-level threads (ULTs)</strong>
and <strong>kernel-level threads (KLTs)</strong>. The latter are also referred to in the literature as
kernel-supported threads or <strong>lightweight processes</strong>.</p>
<h3 id="user-level-threads"><a class="header" href="#user-level-threads">User-level Threads</a></h3>
<p>由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</p>
<p><img src="processes_and_threads/./assets/user_level_threads.png" alt="User-level Threads" /></p>
<ul>
<li>
<p>优点</p>
<ul>
<li>不依赖于操作系统</li>
<li>在<strong>用户空间</strong>实现线程机制
<ul>
<li>每个进程有私有的线程控制块（TCB）列表</li>
<li>TCB 列表又线程库函数维护</li>
</ul>
</li>
<li>同一进程内的用户线程切换速度快</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
</li>
<li>
<p>不足</p>
<ul>
<li>线程发起系统调用而阻塞时，整个线程进入等待。
<ul>
<li>除非当前运行线程主动放弃，否则其所在进程的其他线程无法抢占 CPU</li>
</ul>
</li>
<li>不支持基于线程的<em>处理机</em>抢占，除非当前运行线程主动放弃</li>
<li>只能按进程分配 CPU 时间，即在多线程的多进程中，每个线程分配的时间片较少</li>
</ul>
</li>
</ul>
<h2 id="kernel-level-threads"><a class="header" href="#kernel-level-threads">Kernel-level Threads</a></h2>
<p>由<strong>内核</strong>通过系统调用实现的线程机制，由<strong>内核</strong>实现线程的创建、终止和管理。</p>
<p><img src="processes_and_threads/./assets/kernel_level_threads.png" alt="Kernel-level Threads" /></p>
<p>优点：</p>
<ul>
<li>由内核维护 PCB 和 TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止和切换相对较大：因为通过系统调用或内核函数，在内核中实现</li>
<li>基于线程数量的时间分配：线程数量多的进程 CPU 执行时间多</li>
</ul>
<h3 id="lightweight-process"><a class="header" href="#lightweight-process">Lightweight Process</a></h3>
<p>内核支持的用户线程，一个进程可有一个或多个轻量级进程，每个 Lightweight 进程由一个<strong>单独的内核进程</strong>（即内核线程池）来支持，线程由内核线程池（独立内核进程）执行，但线程与内核线程池之间未绑定。
<img src="processes_and_threads/./assets/lightweight_process.png" alt="Lightweight Process" /></p>
<h2 id="relationship-between-threads-and-processes"><a class="header" href="#relationship-between-threads-and-processes">Relationship between Threads and Processes</a></h2>
<table><thead><tr><th align="center">Threads: Processes</th><th align="center">Description</th><th align="center">Example Systems</th></tr></thead><tbody>
<tr><td align="center">1:1</td><td align="center">Each thread of execution is a unique process with its own address space and resources.</td><td align="center">Traditional UNIX implementations</td></tr>
<tr><td align="center">M:1</td><td align="center">A process defines an address space and dynamic resource ownership. Multiple threads may be created and executed within that process.</td><td align="center">Windows NT, Solaris, Linux, OS/2, OS/390, MACH</td></tr>
<tr><td align="center">1:M</td><td align="center">A thread may migrate from one process environment to another. This allows a thread to be easily moved among distinct systems.</td><td align="center">Ra (Clouds), Emerald</td></tr>
<tr><td align="center">M:N</td><td align="center">It combines attributes of M:1 and 1:M cases.</td><td align="center">TRIX</td></tr>
</tbody></table>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h1>
<h2 id="调度"><a class="header" href="#调度">调度</a></h2>
<ul>
<li>进程切换： CPU 资源占用者的切换</li>
<li>处理机调度：从就绪队列中挑选下个占用 CPU 资源的 <strong>进程</strong>，从多个 CPU 中挑选就绪进程可用的 CPU 资源</li>
<li>调度形式：非抢占式系统、可抢占系统</li>
<li>调度策略：如何从就绪队列中选择下一个执行进程</li>
</ul>
<h2 id="principles-of-scheduling-algorithms"><a class="header" href="#principles-of-scheduling-algorithms">Principles of Scheduling Algorithms</a></h2>
<ul>
<li>CPU 使用率：处于忙状态的<strong>时间百分比</strong></li>
<li>吞吐量：单位时间完成的<strong>进程数量</strong></li>
<li>周转时间：进程从初始化到结束的<strong>总时间</strong></li>
<li>等待时间：进程在就绪队列的总时间</li>
<li>响应时间：从提交请求到产生相应所花费的时间
<em>带宽和延迟不可兼得</em></li>
</ul>
<h2 id="处理机调度策略的相应时间目标"><a class="header" href="#处理机调度策略的相应时间目标">处理机调度策略的相应时间目标</a></h2>
<ul>
<li>减少响应时间</li>
<li>减少平均响应时间的波动（操作系统的计算延迟）</li>
</ul>
<h2 id="处理机调度策略的吞吐量目标"><a class="header" href="#处理机调度策略的吞吐量目标">处理机调度策略的吞吐量目标</a></h2>
<ul>
<li>增加吞吐量：
<ul>
<li>减少开销</li>
<li>系统资源的高效开销</li>
</ul>
</li>
<li>减少等待时间
<ul>
<li>减少每个进程的等待时间</li>
</ul>
</li>
<li>操作系统需要保证吞吐量不受用户交互的影响</li>
</ul>
<h2 id="处理机调度的公平性目标"><a class="header" href="#处理机调度的公平性目标">处理机调度的公平性目标</a></h2>
<p><em>公平不等于公正（例如：富人和穷人缴同等额度的税）</em></p>
<ul>
<li>保证每个进程占用相同的 CPU 的时间</li>
<li>保证每个进程的等待时间相同</li>
<li>公平通常会增加平均响应时间，降低效率</li>
</ul>
<h2 id="调度算法"><a class="header" href="#调度算法">调度算法</a></h2>
<ul>
<li>
<p>先来先服务算法：依据进程进入就绪状态的先后顺序排列（超市结账排队）</p>
<ul>
<li>优点：简单</li>
<li>缺点：
<ul>
<li>平均等待时间波动较大：短进程可能排在长进程后面；</li>
<li>I/O 和 CPU 资源利用较低：CPU 密集进程不使用 I/O，I/O 密集进程不使用 CPU</li>
</ul>
</li>
</ul>
</li>
<li>
<p>短进程优先算法：选择就绪队列中执行时间最短的进程占用 CPU 进入运行状态</p>
<ul>
<li>就绪队列按预期的执行时间来排序</li>
<li>具有最优平均周转时间</li>
<li>连续的段进程流会使长进程无法获得 CPU 资源，对长进程不公平</li>
<li>需要预估下一个 CPU 计算的持续时间（问用户），欺骗就杀死 or 基于历史的记录学习（动量梯度下降） <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>
<p>最高响应比优先算法<br />
选择就绪队列中相应比 R 值最高的进程
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<ul>
<li>w: waiting time</li>
<li>s: service time</li>
</ul>
<p>在短进程有限的基础上进行改进；不可抢占；关注进程的等待时间；防止无限期推迟</p>
</li>
<li>
<p>时间片轮转算法</p>
<ul>
<li>时间片： 分配处理及资源的基本时间单位</li>
<li>算法思路：时间片结束后，按 FCFS (First come, first service) 算法切换到下一个就绪进程；每隔 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个时间片进程执行一个时间片 q</li>
<li>举例：P1-53, P2-8, P3-68, P4-24 （时间片为20）<br />
P1 0-20，P2 20-28，P3 28-48，P4 48-68（P2 已结束）<br />
P1 68-88，P3 88-108，P4 108-112 （P4 已结束）<br />
P1 112-125，P3 125-145 （P1 已结束）<br />
P3 145-153 （P3已结束）<br />
等待时间 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">1</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">2</span></span></span><span style="top:-2.4099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">3</span></span></span><span style="top:-0.9099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500000000000004em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">7</span><span class="mord">2</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord">0</span></span></span><span style="top:-2.4099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mord">5</span></span></span><span style="top:-0.9099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">6</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500000000000004em;"><span></span></span></span></span></span></span></span></span></span></span><br />
平均等待时间：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">6</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span></span></span></span></li>
<li>时间片太大：等待时间太长</li>
<li>时间片太小：开销太大</li>
</ul>
</li>
<li>
<p>多级队列调度算法</p>
<ul>
<li>就绪队列被划分为几个对立的子队列，是上述几种算法的综合</li>
<li>每个队列都有自己的调度策略</li>
<li>队列之间的调度：
<ul>
<li>固定优先级</li>
<li>时间片轮转</li>
</ul>
</li>
<li>多级反馈队列算法
<ul>
<li>进程可在不同队列间移动的多级队列算法</li>
<li>CPU 密集型进程优先级下降得很快</li>
<li>对 I/O 密集型进程有利</li>
</ul>
</li>
</ul>
</li>
<li>
<p>公平共享调度算法</p>
<ul>
<li>公平共享调度控制用户对系统资源的访问</li>
</ul>
</li>
</ul>
<h2 id="实时操作系统"><a class="header" href="#实时操作系统">实时操作系统</a></h2>
<ul>
<li>
<p>定义:正确性依赖于其 <strong>时间</strong> 和 <strong>功能</strong> 两方面的操作系统</p>
</li>
<li>
<p>实时操作系统的性能指标</p>
<ul>
<li>时间约束的及时性</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>
<p>分类</p>
<ul>
<li>强实时操作系统
<ul>
<li>要求在指定时间内必须完成重要的任务</li>
</ul>
</li>
<li>弱实时操作系统
<ul>
<li>重要进程有高优先级</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hard deadline: 错过任务实现会导致灾难性后果;必须验证,在最坏的情况下能够满足实现</p>
</li>
<li>
<p>Soft deadline: 通常能满足任务时限;尽力保证满足任务时限</p>
</li>
<li>
<p>可调度性: 表示一个实时操作系统能够满足任务时限要求</p>
</li>
<li>
<p>实时调度算法</p>
<ul>
<li>速率单调调度算法: 通过 <strong>周期</strong> 安排优先级,周期越短优先级越高</li>
<li>最早截止时间优先算法: 截止时间越早优先级越高</li>
</ul>
</li>
<li>
<p>多处理器调度</p>
<ul>
<li>多个处理机组成一个多处理器系统</li>
<li>处理机间可负载共享</li>
<li>对称多处理机的进程分配:
<ul>
<li>静态进程分配</li>
<li>动态进程分配</li>
</ul>
</li>
<li>优先级反置: 操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象
<ul>
<li>解决方法: 优先级继承、优先级天花板协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="multiple-cores"><a class="header" href="#multiple-cores">Multiple Cores</a></h2>
<h2 id="cache-coherence"><a class="header" href="#cache-coherence">Cache Coherence</a></h2>
<ul>
<li>
<p>Broadcast</p>
</li>
<li>
<p>Flashing</p>
</li>
</ul>
<h2 id="algorithms-1"><a class="header" href="#algorithms-1">Algorithms</a></h2>
<h3 id="sqms-single-queue-multiprocessor-schedule"><a class="header" href="#sqms-single-queue-multiprocessor-schedule">SQMS (Single Queue Multiprocessor Schedule)</a></h3>
<ul>
<li>
<p>Lack of scalability.</p>
</li>
<li>
<p>Weak in cache affinity, violates the locality principle.</p>
</li>
<li>
<p>Let process run in the same CPU, load balance will be invalid.</p>
</li>
<li>
<p>Thus either assure the cache affinity or load balance.</p>
</li>
</ul>
<h3 id="mqms-multi-queue-multiprocessor-scheduling"><a class="header" href="#mqms-multi-queue-multiprocessor-scheduling">MQMS (Multi-Queue Multiprocessor Scheduling)</a></h3>
<ul>
<li>
<p>Queues assign to different CPUs, and the scheduling algorithms can be different.</p>
</li>
<li>
<p>所有进程都可以保持在一个 CPU 上。</p>
</li>
<li>
<p>容易造成负载不均。</p>
</li>
</ul>
<blockquote>
<p>例如：某一个 CPU 任务执行完毕后，该 CPU 处于空转状态。因此只有通过进程的跨 CPU 迁移才能实现负载均衡。</p>
</blockquote>
<ul>
<li>具有可扩展性，队列数可根据 CPU 数进行扩展。</li>
</ul>
<p><strong>如何进行进程工作的迁移？</strong></p>
<ul>
<li>Work stealing: 进程、页表基址等需要迁移。</li>
</ul>
<h2 id="smp-and-linux-kernel"><a class="header" href="#smp-and-linux-kernel">SMP and Linux Kernel</a></h2>
<p>Linux Kernel 2.4 的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 调度算法：<em>initial queue</em> 和 <em>expired queue</em>， 单队列机制。</p>
<p>Linux Kernel 2.6 的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 调度算法：由 Ingo Molnar 设计，由于 Linux 系统有 140 中优先级，因此用一个 140 维的数组存放。在 active bitarray 中寻找 left-most bit 的位置，并在 APA 中寻找 APA[x]， 从 APA[x] 中 dequeue 一个 process，对于当前执行完的 process，重新计算 priority 再 enqueue 到 expired priority array 相应的队列 EPA[x] 中。在一定时间间隔后，要进行 load balance 分析。</p>
<p><strong>操作系统内核和驱动程序属于动态链接库。</strong></p>
<p>CPS 算法：通过计算进程消耗的 CPU 时间而不是优先级来进行调度。占用的资源越少，优先级就越高。但有些进程相比于其他进程更加重要即使执行的时间很长，因此会对每个进程进行赋权。分配给进程的运行时间 = 调度周期 × 进程权重/总权重之和。
Linux 引入 vruntime 进行计算：实际运行时间 × 1024/进程权重。</p>
<p>问题：新进程的 vruntime 为 0，则在相当长时间内都会保持抢占 CPU 的优势，因此应该设定一个最小值从而与老进程保持在一个合理的差距范围内。</p>
<p>休眠进程在唤醒后的 vruntime 相比于其他 active 进程较小，因此会强占 CPU，因此在进程重新唤醒后应该对 vruntime 进行一些补偿。在 Linux 中 sched_features 的 WAKEUP_PREEMPT 位决定在休眠后是否主动强占 CPU。</p>
<p>进程从一个 CPU 迁移到另一个 CPU 上时 vruntime 会不会变？
当一个进程从 CPU_x 出去并进入 CPU_y 的运行队列中时，它的 vruntime = vruntime - min_vruntime_x + min_vruntime_y。</p>
<p>同时 vrumtime 可能会溢出，因此在比较 vruntime 的时候应该先减去 min_vruntime。</p>
<h2 id="bfs-brain-fuck-scheduler"><a class="header" href="#bfs-brain-fuck-scheduler">(BFS) Brain Fuck Scheduler</a></h2>
<p>一种时间片轮转算法的变种，在多处理机情况的但就绪队列选择，增加了队列互斥访问的开销。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mutual-exclusion-and-synchronization"><a class="header" href="#mutual-exclusion-and-synchronization">Mutual Exclusion and Synchronization</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="semaphore"><a class="header" href="#semaphore">Semaphore</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="deadlock-and-starvation"><a class="header" href="#deadlock-and-starvation">Deadlock and Starvation</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="interprocess-communication"><a class="header" href="#interprocess-communication">Interprocess Communication</a></h1>
<h2 id="并发进程的正确性"><a class="header" href="#并发进程的正确性">并发进程的正确性</a></h2>
<h3 id="独立进程"><a class="header" href="#独立进程">独立进程</a></h3>
<ul>
<li>不和其他进程共享资源或状态</li>
<li><strong>确定性</strong>：输入状态决定结果</li>
<li><strong>可重现</strong>：能够重现其实太监</li>
<li>调度顺序不重要</li>
</ul>
<h3 id="并发进程"><a class="header" href="#并发进程">并发进程</a></h3>
<ul>
<li>在多个进程间有资源共享</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
<h3 id="并发正确性"><a class="header" href="#并发正确性">并发正确性</a></h3>
<ul>
<li>执行过程是不确定和不可重现的</li>
<li>程序错误可能是间歇性发生的</li>
</ul>
<h3 id="并发执行的好处"><a class="header" href="#并发执行的好处">并发执行的好处</a></h3>
<ul>
<li>共享资源</li>
<li>加速执行</li>
</ul>
<h2 id="原子操作"><a class="header" href="#原子操作">原子操作</a></h2>
<p>不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换。</p>
<h2 id="原子锁"><a class="header" href="#原子锁">原子锁</a></h2>
<p>Lock.acquire() and Lock.release()</p>
<h2 id="进程的交互关系"><a class="header" href="#进程的交互关系">进程的交互关系</a></h2>
<ul>
<li>mutual exclusion</li>
<li>deadlock</li>
<li>starvation</li>
</ul>
<h2 id="critical-section"><a class="header" href="#critical-section">Critical Section</a></h2>
<ul>
<li>
<p>访问临界资源的代码，任何时候都要互斥执行</p>
</li>
<li>
<p>entry section：检查是否可进入临界区的一段代码,如可进入就设置正在访问临界区标志。</p>
</li>
<li>
<p>exit section: 清除标志。</p>
</li>
<li>
<p>remainder section: 其他部分。</p>
</li>
<li>
<p>临界区访问规则：空闲则入，忙则等待，有效等待，让权等待（可选）</p>
</li>
<li>
<p>实现方法：禁用硬件中断方法、软件方法、更高级的抽象方法。</p>
</li>
</ul>
<h3 id="禁用硬件中断"><a class="header" href="#禁用硬件中断">禁用硬件中断</a></h3>
<ul>
<li>没有中断，就没有上下文切换，因此没有并发</li>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>缺点：进程无法被停止下来，并发度较低；临界区很长，无法确定响应中断所需要的时间。
·</li>
</ul>
<h2 id="基于软件的同步解决方案"><a class="header" href="#基于软件的同步解决方案">基于软件的同步解决方案</a></h2>
<ul>
<li>
<p>方法一：共享变量 <code>turn</code>，表示某线程在临界区。满足「忙则等待」，但有时不满足「空闲则入」。</p>
</li>
<li>
<p>方法二：共享 <code>flag[]</code> 数组，表示线程[] 是否在临界区。存在的问题，两个线程同时 check 对方，不满足忙则等待。</p>
</li>
<li>
<p>方法三：共享 <code>flag[]</code> 数组，表示线程[] 是否想在临界区。如果其他人想，等待；只有自己想，进入。不满足空闲则入，例如两个进程同时想进来。</p>
</li>
<li>
<p>Peterson 算法：两个变量 <code>turn</code> 和 <code>flag[]</code>，<code>flag[]</code> 表示准备进入临界区。但两个进程同时想进入会出现 deadlock。</p>
</li>
<li>
<p>Dekkers 算法</p>
</li>
</ul>
<h2 id="高级抽象的同步方法"><a class="header" href="#高级抽象的同步方法">高级抽象的同步方法</a></h2>
<ul>
<li>锁是一种抽象的数据结构
<ul>
<li>二进制变量（锁定、解锁）</li>
<li>Lock::Acquire</li>
<li>Lock::Release</li>
</ul>
</li>
</ul>
<h2 id="原子操作-1"><a class="header" href="#原子操作-1">原子操作</a></h2>
<ul>
<li>Test and set</li>
<li>exchange</li>
</ul>
<h2 id="用-ts-指令实现自旋锁"><a class="header" href="#用-ts-指令实现自旋锁">用 TS 指令实现自旋锁</a></h2>
<h3 id="test-and-value"><a class="header" href="#test-and-value">Test and value</a></h3>
<pre><code class="language-c++">class Lock {
    int value = 0;
}

Lock::Acquire() {
    while(test-and-set(value)); //spin
}

Lock::Release() {
    value = 0;
}
</code></pre>
<h3 id="exchange"><a class="header" href="#exchange">Exchange</a></h3>
<pre><code class="language-c++">class Lock {
    bool tmp = 1, value = 0;
}

Lock::Acquire() {
    do {XCHG(&amp;value, &amp;tmp);}
    while(tmp == 1);
}

Lock::Release() {
    value = 0;
}
</code></pre>
<p>在锁的数据结构里加上一个等待队列。如果 value 是 0，则将其置 1，不进入 while 循环中；如果 value 是1，则进入 while 循环，将此进程写入到等待队列中，并执行调度程序，其他进程可以继续执行。<br />
释放锁时，把等待队列中的进程写入到就绪队列。
这种方法，使用放弃 CPU 使用权的方式来提高 CPU 利用效率。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<ul>
<li>锁是一种高级的同步抽象方法
<ul>
<li>互斥可以使用锁来实现</li>
<li>需要硬件支持</li>
</ul>
</li>
<li>常用的三种同步实现方法
<ul>
<li>禁用中断（仅限于单处理器）</li>
<li>软件方法（复杂）</li>
<li>原子操作指令（单处理器或多处理器均可）</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="file-system"><a class="header" href="#file-system">File System</a></h1>
<h2 id="files-and-file-systems"><a class="header" href="#files-and-file-systems">Files and File Systems</a></h2>
<p>From the user’s point of view, one of the most important parts of an operating system is the file system. The file system permits users to create data collections, called files, with desirable properties, such as:</p>
<ul>
<li>
<p>Long-term existence: Files are stored on disk or other secondary storage and do not disappear when a user logs off.</p>
</li>
<li>
<p>Sharable between processes: Files have names and can have associated access permissions that permit controlled sharing.</p>
</li>
<li>
<p>Structure: Depending on the file system, a file can have an internal structure that is convenient for particular applications. In addition, files can be organized into a hierarchical or more complex structure to reflect the relationships among files.</p>
</li>
</ul>
<p>Any file system provides not only a means to store data organized as files, but a collection of functions that can be performed on files. Typical operations include the following:</p>
<ul>
<li>Create</li>
<li>Delete</li>
<li>Open</li>
<li>Close</li>
<li>Read</li>
<li>Write</li>
</ul>
<h2 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h2>
<p>Four terms are in common use when discussing files:</p>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<p>A <strong>field</strong> is the basic element of data. Depending on the file design, fields may be fixed length or variable length. In the latter case, the field often consists of fwo or three subfields: the actual value to be stored, the name of the fields, and in some cases, the length of the field. In other cases of variable-length fields, the length of the field is indicated by the use of special demarcation (boundary) symbols between fields.</p>
<h3 id="record"><a class="header" href="#record">Record</a></h3>
<p>A <strong>record</strong> is a collection of related fields that can be treated as a unit by some application program. A record will
be of variable length if some of its fields are of variable length or if the number of fields may vary. In the latter case, each field is usually accompanied by a field name. In either case, the entire record usually includes a length field.</p>
<h3 id="file"><a class="header" href="#file">File</a></h3>
<p>A <strong>file</strong> is a collection of similar records. The file is treated as a single entity by users and applications and may be referenced by name. Files have file names and may be created and deleted.</p>
<h3 id="database"><a class="header" href="#database">Database</a></h3>
<p>A <strong>database</strong> is a collection of related data. The essential aspects of a database are that the relationships that exist among elements of data are explicit.</p>
<h2 id="file-management-systems"><a class="header" href="#file-management-systems">File Management Systems</a></h2>
<p>A file management system is that set of system software that provides services to users and applications in the use of files. Typically, the only way a user or application may access files is through the file management system.<br />
The following objectives for a file management system are as follows:</p>
<ul>
<li>To meet the data management needs and requirements of the user, which include storage of data and the ability to perform the aforementioned operations</li>
<li>To guarantee, to the extend possible, that the data in the file are valid</li>
<li>To optimize performance, both from the system point of view in terms of overall throughput, and from the user’s point of view in terms of response time</li>
<li>To provide I/O support for a variety of storage device types</li>
<li>To minimize or eliminate the potential for lost or destroyed data</li>
<li>To provide a standardized set of I/O interface routines to user processes</li>
<li>To provide I/O support for multiple users, in the case of multiple-user systems</li>
</ul>
<p>With respect to the first point, meeting user requirements, the extent of such requirements depends on the variety of applications and the environment in which the computer system will be used. For an interactive, general-purpose system, the following constitute a minimal set of requirements:</p>
<ol>
<li>Each user should be able to create, delete, read, write, and modify files.</li>
<li>Each user may have controlled access to other users’ files.</li>
<li>Each user may control what types of accesses are allowed to the user’s files</li>
<li>Each user should be able to move data between files.</li>
<li>Each user should be able to back up and recover the user’s files in case of damage.</li>
<li>Each user should be able to access his or her files by name rather than by numeric identifier.</li>
</ol>
<h3 id="file-system-architecture"><a class="header" href="#file-system-architecture">File System Architecture</a></h3>
<p><img src="file_system/./assets/file_system_software_architecture.png" alt="File System Software Architecture" /></p>
<h3 id="file-management-functions"><a class="header" href="#file-management-functions">File Management Functions</a></h3>
<p><img src="file_system/./assets/elements_of_file_management.png" alt="Element of File Management" /></p>
<h2 id="file-organization-and-access"><a class="header" href="#file-organization-and-access">File Organization and Access</a></h2>
<p>In choosing a file organization, several criteria are important:</p>
<ul>
<li>Short access time</li>
<li>Ease of update</li>
<li>Economy of storage</li>
<li>Simple maintenance</li>
<li>Reliability</li>
</ul>
<h3 id="five-fundamental-organizations"><a class="header" href="#five-fundamental-organizations">Five Fundamental Organizations</a></h3>
<ol>
<li>The pile</li>
<li>The sequential file</li>
<li>The indexed sequential file</li>
<li>The indexed file</li>
<li>The direct, or hashed, file</li>
</ol>
<center>
<p><img src="file_system/./assets/common_file_organization.png" alt="Common File Organization" /></p>
</center>
<h2 id="file-directories"><a class="header" href="#file-directories">File Directories</a></h2>
<h3 id="contents"><a class="header" href="#contents">Contents</a></h3>
<p>Associated with any file management system and collection of files is a file directory. The directory contains information about the files, including attributes, location,
and ownership. Much of this information, especially that concerned with storage, is managed by the operating system. The directory is itself a file, accessible by various
file management routines. Although some of the information in directories is available to users and applications, this is generally provided indirectly by system routines.</p>
<h3 id="structure-1"><a class="header" href="#structure-1">Structure</a></h3>
<p>To understand the requirements for a file structure, it is helpful to consider the types of operations that may be performed on the directory:</p>
<ul>
<li>Search: When a user or application references a file, the directory must be searched to find the entry corresponding to that file.</li>
<li>Create file: When a new file is created, an entry must be added to the directory.</li>
<li>Delete file: When a file is deleted, an entry must be removed from the directory.</li>
<li>List directory: All or a portion of the directory may be requested. Generally, this request is made by a user and results in a listing of all files owned by that user, plus some of the attributes of each file (e.g., type, access control information,
usage information).</li>
<li>Update directory: Because some file attributes are stored in the directory, a change in one of these attributes requires a change in the corresponding directory entry.</li>
</ul>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<p>Users need to be able to refer to a file by a symbolic name. Clearly, each file in the system must have a unique name in order that file references be unambiguous. On the other hand, it is an unacceptable burden on users to require they provide unique names, especially in a shared system.</p>
<p>The use of a tree-structured directory minimizes the difficulty in assigning unique names. Any file in the system can be located by following a path from the root or master directory down various branches until the file is reached. The series of directory names, culminating in the file name itself, constitutes a pathname for the file.</p>
<center>
<p><img src="file_system/./assets/tree_structured_directory.png" alt="Tree-structured Directory" /></p>
</center>
<h2 id="file-sharing"><a class="header" href="#file-sharing">File Sharing</a></h2>
<p>In a multi-user system, there is almost always a requirement for allowing files to be shared among a number of users. Two issues arise: access rights and the management of simultaneous access.</p>
<h3 id="access-rights"><a class="header" href="#access-rights">Access Rights</a></h3>
<p>The following list is representative of access rights that can be assigned to a particular user for a particular file:</p>
<ul>
<li>None: The user may not even learn of the existence of the file, much less access it. To enforce this restriction, the user would not be allowed to read the user directory that includes this file.</li>
<li>Knowledge: The user can determine that the file exists and who its owner is. The user is then able to petition the owner for additional access rights.</li>
<li>Execution: The user can load and execute a program but cannot copy it. Proprietary programs are often made accessible with this restriction.</li>
<li>Reading: The user can read the file for any purpose, including copying and execution. Some systems are able to enforce a distinction between viewing and copying. In the former case, the contents of the file can be displayed to the user, but the user has no means for making a copy.</li>
<li>Appending: The user can add data to the file, often only at the end, but cannot modify or delete any of the file’s contents. This right is useful in collecting data from a number of sources.</li>
<li>Updating: The user can modify, delete, and add to the file’s data. This normally includes writing the file initially, rewriting it completely or in part, and removing all or a portion of the data. Some systems distinguish among different degrees of updating.</li>
<li>Changing protection: The user can change the access rights granted to other users. Typically, this right is held only by the owner of the file. In some systems, the owner can extend this right to others. To prevent abuse of this mechanism, the file owner will typically be able to specify which rights can be changed by the holder of this right.</li>
<li>Deletion: The user can delete the file from the file system.</li>
</ul>
<p>One user is designated as the owner of a given file, usually the person who initially created the file. The owner has all of the access rights listed previously and may grant rights to others. Access can be provided to different classes of users:</p>
<ul>
<li>Specific user: Individual users who are designated by user ID</li>
<li>User groups: A set of users who are not individually defined. The system must have some way of keeping track of the membership of user groups.</li>
<li>All: All users who have access to this system. These are public files.</li>
</ul>
<h3 id="simultaneous-access"><a class="header" href="#simultaneous-access">Simultaneous Access</a></h3>
<p>When access is granted to append or update a file to more than one user, the operating system or file management system must enforce discipline. A brute-force approach is to allow a user to lock the entire file when it is to be updated. A finer grain of control is to lock individual records during update. Essentially, this is the readers/writers problem. Issues of mutual exclusion and deadlock must be addressed in designing the shared access capability.</p>
<h2 id="record-blocking"><a class="header" href="#record-blocking">Record Blocking</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
