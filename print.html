<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Overview</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="exception_handling/index.html"><strong aria-hidden="true">2.</strong> Exception Handling</a></li><li class="chapter-item expanded "><a href="memory_management/index.html"><strong aria-hidden="true">3.</strong> Memory Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory_management/contiguous_memory_allocation.html"><strong aria-hidden="true">3.1.</strong> Contiguous Memory Allocation</a></li><li class="chapter-item expanded "><a href="memory_management/noncontiguous_memory_allocation.html"><strong aria-hidden="true">3.2.</strong> Non-contiguous Memory Allocation</a></li></ol></li><li class="chapter-item expanded "><a href="virtual_memory/index.html"><strong aria-hidden="true">4.</strong> Virtual Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="virtual_memory/preliminary_concepts.html"><strong aria-hidden="true">4.1.</strong> Preliminary Concepts</a></li><li class="chapter-item expanded "><a href="virtual_memory/replacement_policy/index.html"><strong aria-hidden="true">4.2.</strong> Replacement Policy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="virtual_memory/replacement_policy/local_replacement.html"><strong aria-hidden="true">4.2.1.</strong> Local Replacement</a></li><li class="chapter-item expanded "><a href="virtual_memory/replacement_policy/global_replacement.html"><strong aria-hidden="true">4.2.2.</strong> Global Replacement</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="processes_and_threads/index.html"><strong aria-hidden="true">5.</strong> Processes and Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="processes_and_threads/processes.html"><strong aria-hidden="true">5.1.</strong> Process</a></li><li class="chapter-item expanded "><a href="processes_and_threads/threads.html"><strong aria-hidden="true">5.2.</strong> Threads</a></li><li class="chapter-item expanded "><a href="processes_and_threads/control.html"><strong aria-hidden="true">5.3.</strong> Control</a></li><li class="chapter-item expanded "><a href="processes_and_threads/schedule_and_dispatch.html"><strong aria-hidden="true">5.4.</strong> Schedule and Dispatch</a></li><li class="chapter-item expanded "><a href="processes_and_threads/multiple_cores.html"><strong aria-hidden="true">5.5.</strong> Multiple Cores</a></li><li class="chapter-item expanded "><a href="processes_and_threads/communication.html"><strong aria-hidden="true">5.6.</strong> Communication</a></li><li class="chapter-item expanded "><a href="processes_and_threads/semaphore.html"><strong aria-hidden="true">5.7.</strong> Semaphore</a></li><li class="chapter-item expanded "><a href="processes_and_threads/monitor.html"><strong aria-hidden="true">5.8.</strong> Monitor</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>There are some simple notes of <em>Operating System</em>. Most contents are copied from slides.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="isolation"><a class="header" href="#isolation">Isolation</a></h2>
<ul>
<li>强制隔离以避免对整个系统的可用性、可靠性和安全影响</li>
<li>运行的程序通常是隔离的单元</li>
<li>防止程序 X 破坏或监视程序 Y
<ul>
<li>读/写内存，使用 100% CPU，更改文件描述符</li>
</ul>
</li>
<li>防止进程干扰操作系统</li>
<li>防止恶意程序、病毒、木马和 bug
<ul>
<li>错误的过程可能会试图欺骗硬件或内核</li>
</ul>
</li>
</ul>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<ul>
<li>地址空间
<ul>
<li>一个程序仅寻址其自己的内存</li>
<li>每个程序若无许可，则无法访问不属于自己的内存</li>
</ul>
</li>
<li>CPU 硬件中的特权模式/中断机制
<ul>
<li>防止应用程序访问设备和敏感的 CPU 寄存器</li>
<li>例如地址空间配置寄存器</li>
<li>例如打断一直占用 CPU 的应用程序</li>
</ul>
</li>
</ul>
<h2 id="program-call"><a class="header" href="#program-call">Program Call</a></h2>
<ul>
<li>好处
<ul>
<li>执行很快</li>
<li>灵活且易于传递和返回复杂数据类型</li>
<li>程序员熟悉的机制</li>
</ul>
</li>
<li>坏处
<ul>
<li>应用程序不可靠，可能有崩溃的风险</li>
</ul>
</li>
</ul>
<h2 id="interrupt"><a class="header" href="#interrupt">Interrupt</a></h2>
<ul>
<li>CPU 硬件支持中断、异常的处理</li>
<li>中断是异步发生的，是来自处理器外部的 I/O 设备的信号结果
<ul>
<li>硬件中断不是由任意一条专门的 CPU 指令造成，从这个意义上它是异步的</li>
</ul>
</li>
<li>硬件中断的异常处理程序通常称为中断处理程序
<ul>
<li>I/O 设备通过向处理器芯片的一个引脚发信号，并将异常信号放到系统总线上以触发中断</li>
<li>在当前指令执行完后，处理器从系统总线读取异常号，保存现场，切换到 Kernel Mode</li>
<li>调用中断处理程序，当中断处理程序完成后，它将控制返回到下一条本来要执行的指令</li>
</ul>
</li>
<li>Timer 可以稳定定时地产生中断
<ul>
<li>防止应用程序一直占用 CPU</li>
<li>让 OS Kernel 能周期性地进行资源管理</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h1>
<h2 id="basic-principles-and-concepts"><a class="header" href="#basic-principles-and-concepts">Basic principles and concepts</a></h2>
<ul>
<li>System Call: 应用程序<strong>主动</strong>向操作系统发出服务请求。</li>
<li>Exception: 由于非法指令或其他原因导致<strong>当前指令执行失败</strong>，（如：内存出错）后的处理请求。</li>
<li>Hardware Interrupt: 来自硬件设备的处理请求。</li>
</ul>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<ul>
<li>源头：
<ul>
<li>中断：外设</li>
<li>异常：应用程序意想不到的行为</li>
<li>系统调用：应用程序请求 OS 服务</li>
</ul>
</li>
<li>相应方式
<ul>
<li>中断：异步</li>
<li>异常：同步</li>
<li>系统调用：异步或同步</li>
</ul>
</li>
<li>处理机制
<ul>
<li>中断：持续且对应用程序透明</li>
<li>异常：杀死或重新继续执行</li>
<li>系统调用：等待和持续</li>
</ul>
</li>
</ul>
<h2 id="interrupt-handling"><a class="header" href="#interrupt-handling">Interrupt Handling</a></h2>
<h3 id="establish-interrupt-mechanisms"><a class="header" href="#establish-interrupt-mechanisms">Establish Interrupt Mechanisms</a></h3>
<ul>
<li>建立中断服务例程
<ul>
<li>初始化
<ul>
<li>设置时钟中断触发次数</li>
<li>设置 <code>sie</code> 的 TI 使能 STIE 位</li>
</ul>
</li>
<li>服务例程
<ul>
<li>调用 OpenSBI 提供的接口设置下次时钟中断触发时间</li>
</ul>
</li>
</ul>
</li>
<li>让 CPU 能响应中断
<ul>
<li>硬件设置
<ul>
<li>sstatus: 保存全局中断的使能位</li>
<li>sie: 指出 CPU 目前能处理或忽略的中断</li>
<li>stvec: 中断入口地址</li>
</ul>
</li>
<li>初始化
<ul>
<li>设定 <code>sie</code> 的 TI 使能 STIE 位</li>
<li>设定 <code>sstatus</code> 的使能中断 SIE 位</li>
<li>实现中断服务总控函数</li>
<li>设置 <code>stvec</code> 指向中断服务总控函数的入口地址</li>
</ul>
</li>
</ul>
</li>
<li>相应并处理中断
<ul>
<li>硬件设置
<ul>
<li>sepc: 保存中断的指令地址</li>
<li>pc: 设置为 <code>stvec</code></li>
<li>scause: 设置中断的来源</li>
<li>sstatus: SIE 位置零以禁用中断</li>
<li>stval: 保存了中断相关的附加信息</li>
</ul>
</li>
<li>软件保存
<ul>
<li>x[0-32]: 通用寄存器</li>
<li>pc: 设置为 <code>stvec</code></li>
<li>scause: 设置为中断的来源</li>
<li>sstatus: SIE 位置零以禁用中断</li>
<li>stval: 保存了中断相关的附加信息</li>
</ul>
</li>
<li>产生中断后
<ul>
<li>硬件设置</li>
<li>软件保存被打断现场</li>
<li>执行软件实现的中断服务例程</li>
<li>软件恢复被打断现场</li>
<li>继续执行</li>
</ul>
</li>
<li>硬件中断服务例程可被打断
<ul>
<li>不同硬件中断源可能在硬件中断处理时出现</li>
<li>中断请求会保持到 CPU 做出响应</li>
<li>硬件中断服务例程中需要临时禁止中断请求</li>
</ul>
</li>
</ul>
</li>
<li>保存或恢复现场
<ul>
<li>还需要为被中断的服务保存和恢复当时程序运行时的上下文
<ul>
<li>x[0-32]: 通用寄存器</li>
<li>sstatus: 系统系状态</li>
<li>sepc: 触发异常/中断的指令地址</li>
<li>scause: 指示发生异常/中断的种类</li>
<li>stval: 保存了发生异常/中断的附加信息</li>
</ul>
</li>
<li>SAVE_ALL 寄存器</li>
</ul>
</li>
</ul>
<h2 id="system-call"><a class="header" href="#system-call">System Call</a></h2>
<p>When an application wants to print a string, it will trigger the system call <code>write()</code>.</p>
<ul>
<li>系统调用
<ul>
<li>在 RISC-V 中，<code>ecall</code> 和 <code>sret</code> 指令用于系统调用</li>
<li>堆栈切换和特权级的转换</li>
</ul>
</li>
<li>函数调用
<ul>
<li>在 RISC-V 中，<code>call</code> 和 <code>ret</code> 指令用于系统调用</li>
<li>无堆栈切换和特权级的转换</li>
</ul>
</li>
</ul>
<h3 id="expenditure-of-system-call"><a class="header" href="#expenditure-of-system-call">Expenditure of System Call</a></h3>
<p>开销会超过函数调用，主要来源：</p>
<ul>
<li>切换内核堆栈</li>
<li>验证参数</li>
<li>切换页表</li>
<li>拷贝数据</li>
</ul>
<h3 id="implementation-of-system-call"><a class="header" href="#implementation-of-system-call">Implementation of System Call</a></h3>
<ul>
<li>应用发起请求</li>
<li><code>std lib</code> 发出系统调用请求
<ul>
<li>发出设置系统调用号和参数，发出 <code>ecall</code></li>
</ul>
</li>
<li>硬件设置
<ul>
<li>sepc：保存请求后的指令地址</li>
<li>pc: 设置为 <code>stvec</code></li>
<li>scause: 设置为 <code>ecall from u-mode</code></li>
<li>sstauts: SIE 位置零以禁用中断</li>
<li>stval: 保存了相关的附件信息</li>
</ul>
</li>
<li>软件保存被打断现场</li>
<li>执行软件实现的中断服务例程</li>
<li>软件恢复现场</li>
<li>应用继续执行</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>In a uniprogramming system, main memory is divided into two parts: one part
for the operating system (resident monitor, kernel) and other part for the program
currently being executed. In a multiprogramming system, the “user” part of
memory must be further subdivided to accommodate multiple processes. The task
of subdivision is carried out dynamically by the operating system and is known as
memory management.</p>
<p>Effective memory management is vital in a multiprogramming system. If only
a few processes are in memory, then for much of the time all of the processes will be
waiting for I/O (input/output), and the processor will be idle. Thus, memory needs to
be allocated to ensure a reasonable supply of ready processes to consume available
processor time.</p>
<p>In this chapter, some key concepts about <strong>contiguous memory allocation</strong> and <strong>non-contiguous memory allocation</strong> will be discussed.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="contiguous-memory-allocation"><a class="header" href="#contiguous-memory-allocation">Contiguous Memory Allocation</a></h1>
<h2 id="the-memory-hierarchy"><a class="header" href="#the-memory-hierarchy">The Memory Hierarchy</a></h2>
<p>A typical hierarchy is illustrated in figure below.</p>
<p><img src="memory_management/./assets/the_memory_hierarchy.png" alt="The Memory Hierarchy" /></p>
<p>As one goes down the hierarchy, the following occur:</p>
<ul>
<li>Decreasing cost per bit</li>
<li>Increasing capacity</li>
<li>Increasing access time</li>
<li>Decreasing frequency of access to the memory by the processor</li>
</ul>
<h2 id="cache-memory"><a class="header" href="#cache-memory">Cache Memory</a></h2>
<p>Although cache memory is invisible to the OS, it interacts with other memory management hardware.</p>
<h2 id="cache-principles"><a class="header" href="#cache-principles">Cache Principles</a></h2>
<p>Cache memory is intended to provide memory access time approaching that of the fastest memories available, and at the same time support a large memory size that has the price of less expensive types of semiconductor memories. The concept is illustrated in the Figure below</p>
<p><img src="memory_management/./assets/single_cache.png" alt="Single Cache" /></p>
<p>There is a relatively large and slow main memory together with a smaller, faster cache memory.</p>
<p>The next Figure depicts the use of multiple levels of cache.</p>
<p><img src="memory_management/./assets/three-level_cache_organization.png" alt="Three-level Cache Organization" /></p>
<p>Main memory consists of up to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> addressable words, with each word having a unique <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>-bit address. For mapping purposes, this memory is considered to consist of a number of fixed length <strong>blocks</strong>
of K words each. That is there are <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> blocks. Cache consists of C <strong>slots</strong> (<em>lines</em>) of K words each, and the number of slots is considerably less than the number of main memory blocks (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>).</p>
<p><img src="memory_management/./assets/cache_main_memory_structure.png" alt="Cache/Main Memory Structure" /></p>
<h2 id="memory-management-methods"><a class="header" href="#memory-management-methods">Memory Management Methods</a></h2>
<ul>
<li>Relocation</li>
<li>Segmentatio   n</li>
<li>Paging</li>
<li>Virtual Memory</li>
</ul>
<h2 id="address-space"><a class="header" href="#address-space">Address Space</a></h2>
<p>The range of addresses available to a computer program.</p>
<ul>
<li>
<p>A logical address is a reference to a memory location <strong>independent</strong> of the current assignment of data to memory; a translation must be made to a physical address before the memory access can be achieved.</p>
</li>
<li>
<p>A relative address is a particular
example of logical address, in which the address is expressed as a location relative to some known point, usually a value in a processor register.</p>
</li>
<li>
<p>A physical address, or absolute address is an <strong>actual</strong> location in main memory.</p>
</li>
</ul>
<h3 id="generating-logical-address"><a class="header" href="#generating-logical-address">Generating Logical Address</a></h3>
<ul>
<li>Compile</li>
<li>Assemble</li>
<li>Link</li>
<li>Relocation</li>
</ul>
<h3 id="procedures"><a class="header" href="#procedures">Procedures</a></h3>
<ul>
<li>CPU
<ul>
<li>ALU: 需要逻辑地址的内存内容</li>
<li>MMU：进行逻辑地址和物理地址的转换</li>
<li>CPU 控制逻辑：给总线发送物理地址请求</li>
</ul>
</li>
<li>内存： 发送物理地址的内容给 CPU 或接受 CPU 数据到物理地址</li>
<li>操作系统：建立逻辑地址与物理地址的映射</li>
</ul>
<h3 id="address-check"><a class="header" href="#address-check">Address Check</a></h3>
<p><img src="memory_management/./assets/address_check.png" alt="Address Check" /></p>
<h2 id="memory-partitioning"><a class="header" href="#memory-partitioning">Memory Partitioning</a></h2>
<p>The principal operation of memory management is to bring processes into main memory for execution by the processor.</p>
<h3 id="fixed-partitioning"><a class="header" href="#fixed-partitioning">Fixed Partitioning</a></h3>
<p>In most schemes for memory management, we can assume the OS occupies some fixed portion of main memory, and the rest of main memory is available for use by multiple processes. The simplest scheme for managing this available memory is to partition it into regions with fixed boundaries.</p>
<h4 id="description"><a class="header" href="#description">Description</a></h4>
<p>Main memory is divided into a number of static partitions <em>at system generation time</em>. A process may be loaded into a partition of <em>equal or greater size</em>.</p>
<h4 id="strengths"><a class="header" href="#strengths">Strengths</a></h4>
<p>Simple to implement; little operating system overhead.</p>
<h4 id="weaknesses"><a class="header" href="#weaknesses">Weaknesses</a></h4>
<p>Inefficient use of memory due to internal fragmentation; maximum number of active processes is fixed.</p>
<p><img src="memory_management/./assets/example_of_fixed_partitioning.png" alt="Example of Fixed Partitioning" /></p>
<p>With unequal-size partitions, there are two possible ways to assign processes to partitions. The simplest way is to assign each process to the smallest partition within which it will fit. In this case, a scheduling queue is needed for each partition to hold swapped-out processes destined for that partition</p>
<h3 id="internal-fragmentation"><a class="header" href="#internal-fragmentation">Internal Fragmentation</a></h3>
<p>Occurs when memory is divided into fixed-size partitions (e.g., page frames in main memory, physical blocks on disk). If a block of data is assigned to one or more partitions, then there may be wasted space in the last partition. This will occur if the last portion of data is smaller than the last partition.</p>
<h3 id="external-fragmentation"><a class="header" href="#external-fragmentation">External Fragmentation</a></h3>
<p>Occurs when memory is divided into variable-size partitions corresponding to the blocks of data assigned to the memory (e.g., segments in main memory). As segments are moved into and out of the memory, gaps will occur between the occupied portions of memory.</p>
<h3 id="dynamic-partitioning"><a class="header" href="#dynamic-partitioning">Dynamic Partitioning</a></h3>
<h4 id="description-1"><a class="header" href="#description-1">Description</a></h4>
<p>Partitions are created dynamically, so each process is loaded into a partition of exactly the same size as that process. Data structure is used in dynamic partitioning to maintain allocated blocks and empty blocks.</p>
<h4 id="strengths-1"><a class="header" href="#strengths-1">Strengths</a></h4>
<p>No internal fragmentation; more efficient use of main memory.</p>
<h4 id="weaknesses-1"><a class="header" href="#weaknesses-1">Weaknesses</a></h4>
<p>Inefficient use of processor due to the need for compaction to counter external fragmentation.</p>
<h4 id="placement-algorithms"><a class="header" href="#placement-algorithms">Placement Algorithms</a></h4>
<p>Three placement algorithms that might be considered are <strong>best-fit, first-fit, and next-fit</strong>. All, of course, are limited to choosing among free blocks of main memory that are equal to or larger than the process to be brought in. <strong>Best-fit</strong> chooses the block that is closest in size to the request. <strong>First-fit</strong> begins to scan memory from the beginning and chooses the first available block that is large enough. <strong>Next-fit</strong> begins to scan memory from the location of the last placement and chooses the next available block that is large enough.</p>
<ul>
<li>
<p>Best-fit: 分配 n 字节的分区时，查找并使用不小于 n 的最小空闲分区</p>
<ul>
<li>原理及实现
<ul>
<li>空闲分区列表按大小排序</li>
<li>分配时查找一个合适的分区</li>
<li>释放时查找并合并邻近的空闲分区</li>
</ul>
</li>
<li>优点
<ul>
<li>大部分分配块的尺寸较小时效果较好</li>
<li>可避免大的空闲分区被拆分</li>
<li>可减小外部碎片的大小</li>
<li>实现简单</li>
</ul>
</li>
<li>缺点
<ul>
<li>容易产生外部碎片</li>
<li>释放分区速度较慢</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Worst-fit: 分配 n 字节，使用尺寸不小于 n 的最大空闲分区</p>
<ul>
<li>
<p>原理及实现</p>
<ul>
<li>空闲分区列表按由大到小排序</li>
<li>分配时，选最大的分区</li>
<li>释放时，尽可能与邻近分区合并，并调整空闲分区列表顺序</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>中等大小的分配请求较多时，效果最好</li>
<li>不会出现太多的小碎片</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>释放分区速度较慢</li>
<li>容易产生外部碎片</li>
<li>容易破坏大的空闲分区</li>
</ul>
</li>
</ul>
</li>
<li>
<p>First-fit: 分配 n 个字节，使用第一个可用的空间比 n 大的空闲块。</p>
<ul>
<li>原理及实现
<ul>
<li>空闲分区列表按地址顺序排序</li>
<li>分配时，选第一个合适的分区</li>
<li>释放时，尽可能与邻近分区合并</li>
</ul>
</li>
<li>优点
<ul>
<li>实现简单</li>
<li>在高地址空间有大块的空闲分区</li>
</ul>
</li>
<li>缺点
<ul>
<li>分配大块空间速度较慢</li>
<li>容易产生外部碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="defragmentation"><a class="header" href="#defragmentation">Defragmentation</a></h3>
<p>通过调整进程占用的分区位置来减少或避免分区碎片。</p>
<h4 id="compaction"><a class="header" href="#compaction">Compaction</a></h4>
<p>通过移动分配给进程的内存分区，以合并外部碎片。<br />
碎片紧凑的条件：所有的应用程序可动态重定位。</p>
<h4 id="swapping-inout"><a class="header" href="#swapping-inout">Swapping in/out</a></h4>
<p>通过抢占并回收处于等待状态进程的分区，以增大可用内存空间</p>
<h2 id="buddy-system"><a class="header" href="#buddy-system">Buddy System</a></h2>
<p>Both fixed and dynamic partitioning schemes have drawbacks. A fixed partitioning scheme limits the number of active processes and may use space inefficiently if there is a poor match between available partition sizes and process sizes. A dynamic partitioning scheme is more complex to maintain and includes the overhead of compaction. An interesting compromise is the buddy system.
In a buddy system, memory blocks are available of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span> words, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>, where</p>
<ul>
<li>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> small size block that allocated</p>
</li>
<li>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> largest size block that is allocated; generally <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> is the size of the entire memory available for allocation</p>
</li>
</ul>
<p>To begin, the entire space available for allocation is treated as a single block of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span>. If a request of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> such that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> is made, then the entire block is allocated. Otherwise, the block is split into two equal buddies of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>. This process continues until the smallest block greater than or equal to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> is generated and allocated to the request. At any time, the buddy system maintains a list of holes (unallocated blocks) of each size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>. A hole may be removed from the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> list by splitting it in half to create two buddies of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span> in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> list. Whenever a pair of buddies on the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> list both become unallocated,they are removed from that list and coalesced into a single block on the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> list. Presented with a request for an allocation of size <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> such that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.863764em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>.<br />
The Figure below gives an example using a 1-Mbyte initial block.</p>
<p><img src="memory_management/./assets/example_of_buddy_system.png" alt="Example of Buddy System" /></p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<ul>
<li>数据结构
<ul>
<li>空闲块按大小和起始地址组织成二维数组</li>
<li>初始状态：只有一个大小为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> 的空闲块</li>
</ul>
</li>
<li>分配过程
<ul>
<li>由小到大在空闲块数组中找最小的可用空闲块</li>
<li>如空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块</li>
</ul>
</li>
<li>释放过程
<ul>
<li>把释放的块放入空闲块数组</li>
<li>合并满足合并条件的空闲块</li>
</ul>
</li>
<li>合并条件
<ul>
<li>大小相同为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></li>
<li>地址相邻</li>
<li>低地址空闲块起始地址为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord cjk_fallback mtight">＋</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 的倍数</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="non-contiguous-memory-allocation"><a class="header" href="#non-contiguous-memory-allocation">Non-contiguous Memory Allocation</a></h1>
<ul>
<li>设计目标：提高内存利用效率和管理灵活性</li>
<li>优点
<ul>
<li>允许一个程序的使用非连续的物理地址空间</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
</li>
</ul>
<h2 id="segmentation"><a class="header" href="#segmentation">Segmentation</a></h2>
<h3 id="segmented-address-space"><a class="header" href="#segmented-address-space">Segmented Address Space</a></h3>
<p>进程的段地址空间由多个段组成：主代码段、子模块代码段、公用库代码段、堆栈段（stack）、堆数据（heap）、初始化数据段和符号表等。<br />
段式存储管理的目的在于<strong>更细粒度和灵活的分离与共享</strong>。</p>
<h3 id="access-mechanisms"><a class="header" href="#access-mechanisms">Access Mechanisms</a></h3>
<ul>
<li>
<p>段的概念</p>
<ul>
<li>段表示访问方式和储存数据等属性相同的一段地址空间。</li>
<li>对应一个连续的内存块</li>
<li>若干个段组成逻辑地址空间</li>
</ul>
</li>
<li>
<p>段访问： 逻辑地址由段基址+段内偏移组成的二元组<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">s</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">a</span><span class="mord mathrm">d</span><span class="mord mathrm">d</span><span class="mord mathrm">r</span></span><span class="mclose">)</span></span></span></span>构成</p>
</li>
</ul>
<h2 id="paging"><a class="header" href="#paging">Paging</a></h2>
<ul>
<li>Frame: 把物理地址空间划分为大小相同的基本分配单位（2 的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 次方）</li>
<li>Page: 把逻辑地址空间也划分为相同大小的基本分配单位</li>
<li>Frame 和 Page 的大小必须是相同的</li>
</ul>
<h3 id="frame"><a class="header" href="#frame">Frame</a></h3>
<p>物理内存被划分为相同大小的帧，用二元组 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">o</span><span class="mclose">)</span></span></span></span> 表示，其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 代表帧号（共有 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span> 个帧），每个帧有 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span> 个字节。因此物理地址计算公式为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span></p>
<h3 id="page"><a class="header" href="#page">Page</a></h3>
<p>进程逻辑地址空间被划分为大小相等的页，通常来讲，页内偏移等于段内偏移但页号不等于帧号。逻辑地址由二元组 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">o</span><span class="mclose">)</span></span></span></span> 表示，虚拟地址计算公式为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span></p>
<h3 id="address-mapping"><a class="header" href="#address-mapping">Address Mapping</a></h3>
<ul>
<li>逻辑地址中的页号是连续的</li>
<li>物理地址中的帧号不是连续的</li>
<li><strong>不是</strong>所有的页都有相应的帧对应</li>
</ul>
<h3 id="page-tables"><a class="header" href="#page-tables">Page Tables</a></h3>
<p>Page tables save the information of the mapping from logical addresses to physical addresses.</p>
<p>每一个进程都有一个页表，每一个页面对应一个页表项，通过 Page Table Base Register (PTBR) 实现页面到页表项之间的映射。</p>
<ul>
<li>页表项的构成
<ul>
<li>帧号：f</li>
<li>页表项标志
<ul>
<li>存在位</li>
<li>修改位</li>
<li>引用位</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="performance-problem"><a class="header" href="#performance-problem">Performance Problem</a></h3>
<ol>
<li>访问一个内存单元需要先访问页表，再访问数据。</li>
<li>页表可能会非常大</li>
</ol>
<p>How to solve: Caching or Indirection</p>
<h2 id="translation-lookaside-buffer"><a class="header" href="#translation-lookaside-buffer">Translation Lookaside Buffer</a></h2>
<p>Translation lookaside buffer (TLB) functions in
the same way as a memory cache and contains those page table
entries that have been most recently used. The organization of the resulting paging
hardware is illustrated in Figure below. Given a virtual address, the processor will first examine the TLB. If the desired page table entry is present (TLB hit), then the frame number is retrieved and the real address is formed. If the desired page table entry is
not found (TLB miss), then the processor uses the page number to index the process page table and examine the corresponding page table entry. If the “present bit” is set, then the page is in main memory, and the processor can retrieve the frame number
from the page table entry to form the real address. The processor also updates the
TLB to include this new page table entry. Finally, if the present bit is not set, then the desired page is not in main memory and a memory access fault, called a page fault, is issued.</p>
<p><img src="memory_management/./assets/use_of_a_tlb.png" alt="Use of a Translation Lookaside Buffer" /></p>
<h3 id="hierarchical-page-table"><a class="header" href="#hierarchical-page-table">Hierarchical Page Table</a></h3>
<p>Take a two-level hierarchical page table as an example:</p>
<p><img src="memory_management/./assets/a_two_level_hierarchical_page_table.png" alt="A Two-Level Hierarchical Page Table" /></p>
<p><img src="memory_management/./assets/address_translation_in_a_hierarchical_paging_system.png" alt="Address Translation in a Two-Level Paging System" /></p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="virtual-memory"><a class="header" href="#virtual-memory">Virtual Memory</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="preliminary-concepts"><a class="header" href="#preliminary-concepts">Preliminary Concepts</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="replacement-policy"><a class="header" href="#replacement-policy">Replacement Policy</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="local-replacement"><a class="header" href="#local-replacement">Local Replacement</a></h1>
<h2 id="basic-algorithms"><a class="header" href="#basic-algorithms">Basic Algorithms</a></h2>
<h3 id="optimal"><a class="header" href="#optimal">Optimal</a></h3>
<ul>
<li>Selects for replacement that page for which the time to the next reference is the longest.</li>
<li>Impossible to implement</li>
<li>Benchmark algorithm</li>
</ul>
<h3 id="least-recently-used-lru"><a class="header" href="#least-recently-used-lru">Least recently used (LRU)</a></h3>
<ul>
<li>Replaces the page in memory that has not been referenced for the long time.</li>
<li>Does nearly as well as the optimal policy.</li>
<li>Implement by linked list or stack, ordered by visit time, with high time complexity.</li>
</ul>
<h3 id="first-in-first-out-fifo"><a class="header" href="#first-in-first-out-fifo">First-in-first-out (FIFO)</a></h3>
<ul>
<li>Process as a circular buffer</li>
<li>May cause <em>belady anomaly</em></li>
<li>Easy to implement</li>
</ul>
<h3 id="clock"><a class="header" href="#clock">Clock</a></h3>
<ul>
<li>Organize frames in a circular buffer.</li>
<li>First loaded or subsequently referenced, use bit = 1.</li>
<li>When replace, find a frame with use bit = 0, and reset use bit of frames that each scan encounters to 0.</li>
<li>If all of the frames have a use bit of 1, then the pointer will make one complete cycle through the buffer, setting all the use bits to 0, and stop at its original position, replacing the page in that frame.</li>
<li>An implementation of LRU using FIFO mechanism.</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p><img src="virtual_memory/replacement_policy/./assets/algorithm_compare.png" alt="Algorithm Compare" /></p>
<h2 id="infrequent-algorithms"><a class="header" href="#infrequent-algorithms">Infrequent Algorithms</a></h2>
<h3 id="improved-clock"><a class="header" href="#improved-clock">Improved Clock</a></h3>
<ol>
<li>Not accessed recently, not modified (u = 0; m = 0)</li>
<li>Accessed recently, not modified (u = 1; m = 0)</li>
<li>Not accessed recently, modified (u = 0; m = 1)</li>
<li>Accessed recently, modified (u = 1; m = 1)</li>
</ol>
<ul>
<li>Beginning at the current position of the pointer, scan the frame buffer. During
this scan, make no changes to the use bit. The first frame encountered with
(u = 0; m = 0) is selected for replacement.</li>
<li>If step 1 fails, scan again, looking for the frame with (u = 0; m = 1). The first
such frame encountered is selected for replacement. During this scan, set the
use bit to 0 on each frame that is bypassed.</li>
<li>If step 2 fails, the pointer should have returned to its original position and all
of the frames in the set will have a use bit of 0. Repeat step 1 and, if necessary,
step 2. This time, a frame will be found for the replacement.</li>
</ul>
<p>In brief, the transitions of each state are shown in the table below,</p>
<table><thead><tr><th align="center">Use Bit</th><th align="center">Modify Bit</th><th align="center">Next State</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">0</td><td align="center">swap</td></tr>
<tr><td align="center">0</td><td align="center">1</td><td align="center">0 0</td></tr>
<tr><td align="center">1</td><td align="center">0</td><td align="center">0 0</td></tr>
<tr><td align="center">1</td><td align="center">1</td><td align="center">0 1</td></tr>
</tbody></table>
<h3 id="least-frequently-used"><a class="header" href="#least-frequently-used">Least Frequently Used</a></h3>
<ul>
<li>Replace the block in the set that has experienced the fewest references.</li>
<li>could be implemented by associating a counter with each block.</li>
<li>When a block is brought in, it is assigned a count of 1; with each reference to the block, its count is incremented by 1. When replacement is required, the block with the smallest count is selected.</li>
<li>Make poor replacement choices when certain blocks are referenced relatively infrequently overall, but frequently in some short intervals.</li>
</ul>
<h2 id="belady-anomaly"><a class="header" href="#belady-anomaly">Belady Anomaly</a></h2>
<p>Conflicts between the FIFO algorithm and the memory dynamic feature.</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="global-replacement"><a class="header" href="#global-replacement">Global Replacement</a></h1>
<p>A global replacement policy considers all unlocked pages in main memory as candidates for replacement, regardless of which process owns a particular page.</p>
<h2 id="working-set-strategy"><a class="header" href="#working-set-strategy">Working Set Strategy</a></h2>
<ul>
<li>
<p>Working Set: The working set with parameter <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> for a process at virtual time <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>, which we designate as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span></span></span></span>, is the set of pages of that process that have been referenced in the last <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> virtual time units.</p>
</li>
<li>
<p>Resident Set:</p>
</li>
<li>
<p>Algorithm</p>
</li>
</ul>
<h2 id="relation-between-page-size-and-page"><a class="header" href="#relation-between-page-size-and-page">Relation between Page Size and Page</a></h2>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="processes-and-threads"><a class="header" href="#processes-and-threads">Processes and Threads</a></h1>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="processes"><a class="header" href="#processes">Processes</a></h1>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器：CR0, IP</li>
<li>通用寄存器：AX, BX, CX</li>
<li>An associated set of system resources</li>
</ul>
<h3 id="feature"><a class="header" href="#feature">Feature</a></h3>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>制约性</li>
</ul>
<h3 id="relation-between-programs"><a class="header" href="#relation-between-programs">Relation between programs</a></h3>
<p>Abstract of Programs in executive states<br />
Program = Static executive file<br />
Process = Program + executive states<br />
A program may own different process</p>
<h2 id="process-control-block"><a class="header" href="#process-control-block">Process Control Block</a></h2>
<p>操作系统用 PCB 来进程的基本状态</p>
<h3 id="基本状态"><a class="header" href="#基本状态">基本状态</a></h3>
<p>包含：</p>
<ul>
<li>进程的标识信息</li>
<li>处理机现场保存</li>
<li>进程的控制信息</li>
</ul>
<p>At any given point in time, while the program is executing, this process can be uniquely characterized by a number of elements, including the following:</p>
<ul>
<li>Identifier: A unique identifier associated with this process, to distinguish it from all other processes.</li>
<li>State: If the process is currently executing, it is in the running state.</li>
<li>Priority: Priority level relative to other processes.</li>
<li>Program counter: The address of the <em>next instruction</em> in the program to be executed.</li>
<li>Memory pointers: Include pointers to the program code and data associated
with this process, plus any memory blocks shared with other processes.</li>
<li>Context data: These are data that are present in registers in the processor while the process is executing.</li>
<li>I/O status information: Includes outstanding I/O requests, I/O devices assigned to this process, a list of files in use by the process, and so on.</li>
<li>Accounting information: May include the amount of processor time and clock time used, time limits, account numbers, and so on.</li>
</ul>
<h3 id="控制信息"><a class="header" href="#控制信息">控制信息</a></h3>
<ul>
<li>
<p>调度和状态信息： 调度进程和处理及使用情况</p>
</li>
<li>
<p>进程间通信信息： 进程间通信相关的各种标识</p>
</li>
<li>
<p>储存管理信息</p>
</li>
<li>
<p>进程所用资源</p>
</li>
<li>
<p>有关数据结构的连接信息</p>
</li>
</ul>
<h3 id="组织形式"><a class="header" href="#组织形式">组织形式</a></h3>
<ul>
<li>链表：同一状态进程的 PCB 组成链表</li>
<li>索引表：统一状态进程的 PCB 被同一索引指向</li>
</ul>
<h2 id="process-states"><a class="header" href="#process-states">Process States</a></h2>
<h3 id="creation"><a class="header" href="#creation">Creation</a></h3>
<p>When a new process is to be added to those currently being managed, the OS builds the data structures used to manage the process, and allocates address space in main memory to the process.</p>
<h4 id="reasons"><a class="header" href="#reasons">Reasons</a></h4>
<ul>
<li>New batch job</li>
<li>Created by OS to provide a service</li>
<li>Interactive log-on</li>
<li>Spawned by existing process</li>
</ul>
<h3 id="ready"><a class="header" href="#ready">Ready</a></h3>
<h3 id="blockedwaiting"><a class="header" href="#blockedwaiting">Blocked/Waiting</a></h3>
<p>A process that cannot execute until some event occurs, such as the completion of an I/O operation.</p>
<h4 id="reasons-1"><a class="header" href="#reasons-1">Reasons</a></h4>
<ul>
<li>请求并等 待系统服务</li>
<li>启动某种操作无法马上完成</li>
<li>需要的数据没有到达</li>
</ul>
<h3 id="强占"><a class="header" href="#强占">强占</a></h3>
<p>高优先级进程就绪
进程运行时间已结束</p>
<h3 id="唤醒"><a class="header" href="#唤醒">唤醒</a></h3>
<h3 id="结束"><a class="header" href="#结束">结束</a></h3>
<p>正常/错误/致命错误/被其他进程所杀</p>
<p>操作系统在 <strong>中断</strong> 中处理进程<br />
以 <em>Sleep()</em> 为例，创建 -&gt; 就绪 -&gt; 运行 -&gt; 等待 -&gt; 操作系统时钟中断 ...</p>
<p>Running, ready and blocked states are three basic states.<br />
Five-state Process Module: New, ready, running, blocked and exit.</p>
<p>等待状态结束后重新回到就绪队列。</p>
<h2 id="suspended-processes"><a class="header" href="#suspended-processes">Suspended Processes</a></h2>
<p>把一个进程从内存转到外存，低优先级让位高优先级。</p>
<ul>
<li>等待挂起 (Block-suspend)</li>
<li>就绪挂起 (Ready-suspend)</li>
</ul>
<h2 id="activated-processes"><a class="header" href="#activated-processes">Activated Processes</a></h2>
<p>把一个进程从外存转到内存</p>
<p>就绪挂起 -&gt; 就绪：没有就绪进程或挂起或有高优先级的挂起进程<br />
等待挂起 -&gt; 等待</p>
<h2 id="state-queue"><a class="header" href="#state-queue">State Queue</a></h2>
<p>根据不同优先级，就绪队列和等待队列可能有多个。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>多进程的问题：</p>
<ol>
<li>如何通信、如何共享数据</li>
<li>系统开销较大，涉及进程的创建、进程的终止等</li>
</ol>
<h2 id="concepts-1"><a class="header" href="#concepts-1">Concepts</a></h2>
<p>线程是进程的一部分，描述指令流执行状态，它是进程中指令执行流的最小单位，是 CPU 调度的基本单位。
<strong>堆栈 (Heap) 资源不能共享</strong>
线程是资源调度的基本单位，因此同一个进程内的线程共享其资源。</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ol>
<li>Resource ownership: A process includes a virtual address space to hold the process image; The process image is the collection of program, data, stack, and attributes defined in the process control block. From time to time, a process may be allocated control or ownership of resources,such as main memory, I/O channels, I/O devices, and files. The OS performs a protection function to prevent unwanted interference between processes with respect to resources.</li>
<li><strong>Scheduling/execution</strong>: The execution of a process follows an execution path (trace) through one or more programs. This execution maybe interleaved with that of other processes. Thus, a process has an execution state (Running, Ready, etc.) and a dispatching priority, and is the entity that is scheduled and dispatched by the OS.</li>
</ol>
<h2 id="pros-and-cons"><a class="header" href="#pros-and-cons">Pros and Cons</a></h2>
<p>优点：</p>
<ol>
<li>一个进程同时存在线程。</li>
<li>多线程之间可以并发。</li>
<li>线程间共享地址空间和文件等资源。</li>
</ol>
<p>缺点：一个进程崩溃，其他进程也会崩溃。</p>
<center>
<p><img src="processes_and_threads/./assets/multithreading.png" alt="multithreading" /></p>
</center>
<h2 id="implementation-methods"><a class="header" href="#implementation-methods">Implementation Methods</a></h2>
<ul>
<li>User-Level threads: 用户级的线程库函数来完成线程的管理</li>
<li>Kernel-Level threads</li>
<li>Lightweight Process</li>
</ul>
<h3 id="user-level-threads"><a class="header" href="#user-level-threads">User-Level Threads</a></h3>
<ul>
<li>不依赖于操作系统</li>
<li>在用户空间实现线程机制</li>
<li>同一进程内的用户线程切换速度快</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
<p>不足：</p>
<ul>
<li>线程发起系统调用而阻塞时，整个线程进入等待。</li>
<li>不支持基于线程的<em>处理机</em>抢占，除非当前运行线程主动放弃</li>
<li>只能按进程分配 CPU 时间</li>
</ul>
<h2 id="kernel-level-threads"><a class="header" href="#kernel-level-threads">Kernel-Level Threads</a></h2>
<p>由<strong>内核</strong>通过系统调用实现的线程机制，由<strong>内核</strong>实现线程的创建、终止和管理。</p>
<p>特点：</p>
<ul>
<li>由内核维护 PCB 和 TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止和切换相对较大：因为在内核中实现</li>
<li>基于线程数量的时间分配：线程数量多的进程 CPU 执行时间多</li>
</ul>
<h3 id="lightweight-process"><a class="header" href="#lightweight-process">Lightweight Process</a></h3>
<p>内核支持的用户线程，一个进程可有一个或多个轻量级进程，每个 Lightweight 进程由一个<strong>单独的内核进程</strong>（即内核线程池）来支持，线程由内核线程池（独立内核进程）执行，但线程与内核线程池之间未绑定。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="control"><a class="header" href="#control">Control</a></h1>
<h2 id="switch-processes"><a class="header" href="#switch-processes">Switch Processes</a></h2>
<ul>
<li>暂停当前运行进程，从运行状态变为其他状态</li>
<li>调度另一个进程从就绪状态变为运行状态</li>
</ul>
<p>When to Switch Processes:</p>
<ul>
<li>Clock interrupt</li>
<li>I/O interrupt</li>
<li>Memory fault</li>
</ul>
<h3 id="要求"><a class="header" href="#要求">要求</a></h3>
<ul>
<li>切换前，保存进程上下文（保存至 PCB）</li>
<li>切换后，恢复进程上下文</li>
<li>快速切换</li>
</ul>
<h3 id="进程生命周期的信息"><a class="header" href="#进程生命周期的信息">进程生命周期的信息</a></h3>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器：CR0, IP</li>
<li>通用寄存器：AX, BX, CX</li>
<li>An associated set of system resources</li>
</ul>
<h3 id="上下文切换"><a class="header" href="#上下文切换">上下文切换</a></h3>
<p>以进程 P0、进程 P1 为例：<br />
P0 -- 中断或系统调用 -- P0 保存 -- P1 恢复 -- P1 -- 中断或系统调用 -- P1 保存 -- P0 恢复 -- P0</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="schedule-and-dispatch"><a class="header" href="#schedule-and-dispatch">Schedule and Dispatch</a></h1>
<h2 id="调度"><a class="header" href="#调度">调度</a></h2>
<ul>
<li>进程切换： CPU 资源占用者的切换</li>
<li>处理机调度：从就绪队列中挑选下个占用 CPU 资源的 <strong>进程</strong>，从多个 CPU 中挑选就绪进程可用的 CPU 资源</li>
<li>调度形式：非抢占式系统、可抢占系统</li>
<li>调度策略：如何从就绪队列中选择下一个执行进程</li>
</ul>
<h2 id="principles-of-scheduling-algorithms"><a class="header" href="#principles-of-scheduling-algorithms">Principles of Scheduling Algorithms</a></h2>
<ul>
<li>CPU 使用率：处于忙状态的<strong>时间百分比</strong></li>
<li>吞吐量：单位时间完成的<strong>进程数量</strong></li>
<li>周转时间：进程从初始化到结束的<strong>总时间</strong></li>
<li>等待时间：进程在就绪队列的总时间</li>
<li>响应时间：从提交请求到产生相应所花费的时间
<em>带宽和延迟不可兼得</em></li>
</ul>
<h2 id="处理机调度策略的相应时间目标"><a class="header" href="#处理机调度策略的相应时间目标">处理机调度策略的相应时间目标</a></h2>
<ul>
<li>减少响应时间</li>
<li>减少平均响应时间的波动（操作系统的计算延迟）</li>
</ul>
<h2 id="处理机调度策略的吞吐量目标"><a class="header" href="#处理机调度策略的吞吐量目标">处理机调度策略的吞吐量目标</a></h2>
<ul>
<li>增加吞吐量：
<ul>
<li>减少开销</li>
<li>系统资源的高效开销</li>
</ul>
</li>
<li>减少等待时间
<ul>
<li>减少每个进程的等待时间</li>
</ul>
</li>
<li>操作系统需要保证吞吐量不受用户交互的影响</li>
</ul>
<h2 id="处理机调度的公平性目标"><a class="header" href="#处理机调度的公平性目标">处理机调度的公平性目标</a></h2>
<p><em>公平不等于公正（例如：富人和穷人缴同等额度的税）</em></p>
<ul>
<li>保证每个进程占用相同的 CPU 的时间</li>
<li>保证每个进程的等待时间相同</li>
<li>公平通常会增加平均响应时间，降低效率</li>
</ul>
<h2 id="调度算法"><a class="header" href="#调度算法">调度算法</a></h2>
<ul>
<li>
<p>先来先服务算法：依据进程进入就绪状态的先后顺序排列（超市结账排队）</p>
<ul>
<li>优点：简单</li>
<li>缺点：
<ul>
<li>平均等待时间波动较大：短进程可能排在长进程后面；</li>
<li>I/O 和 CPU 资源利用较低：CPU 密集进程不使用 I/O，I/O 密集进程不使用 CPU</li>
</ul>
</li>
</ul>
</li>
<li>
<p>短进程优先算法：选择就绪队列中执行时间最短的进程占用 CPU 进入运行状态</p>
<ul>
<li>就绪队列按预期的执行时间来排序</li>
<li>具有最优平均周转时间</li>
<li>连续的段进程流会使长进程无法获得 CPU 资源，对长进程不公平</li>
<li>需要预估下一个 CPU 计算的持续时间（问用户），欺骗就杀死 or 基于历史的记录学习（动量梯度下降） <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>
<p>最高响应比优先算法<br />
选择就绪队列中相应比 R 值最高的进程
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<ul>
<li>w: waiting time</li>
<li>s: service time</li>
</ul>
<p>在短进程有限的基础上进行改进；不可抢占；关注进程的等待时间；防止无限期推迟</p>
</li>
<li>
<p>时间片轮转算法</p>
<ul>
<li>时间片： 分配处理及资源的基本时间单位</li>
<li>算法思路：时间片结束后，按 FCFS (First come, first service) 算法切换到下一个就绪进程；每隔 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个时间片进程执行一个时间片 q</li>
<li>举例：P1-53, P2-8, P3-68, P4-24 （时间片为20）<br />
P1 0-20，P2 20-28，P3 28-48，P4 48-68（P2 已结束）<br />
P1 68-88，P3 88-108，P4 108-112 （P4 已结束）<br />
P1 112-125，P3 125-145 （P1 已结束）<br />
P3 145-153 （P3已结束）<br />
等待时间 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">1</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">2</span></span></span><span style="top:-2.4099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">3</span></span></span><span style="top:-0.9099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500000000000004em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">7</span><span class="mord">2</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord">0</span></span></span><span style="top:-2.4099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mord">5</span></span></span><span style="top:-0.9099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">6</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500000000000004em;"><span></span></span></span></span></span></span></span></span></span></span><br />
平均等待时间：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">6</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span></span></span></span></li>
<li>时间片太大：等待时间太长</li>
<li>时间片太小：开销太大</li>
</ul>
</li>
<li>
<p>多级队列调度算法</p>
<ul>
<li>就绪队列被划分为几个对立的子队列，是上述几种算法的综合</li>
<li>每个队列都有自己的调度策略</li>
<li>队列之间的调度：
<ul>
<li>固定优先级</li>
<li>时间片轮转</li>
</ul>
</li>
<li>多级反馈队列算法
<ul>
<li>进程可在不同队列间移动的多级队列算法</li>
<li>CPU 密集型进程优先级下降得很快</li>
<li>对 I/O 密集型进程有利</li>
</ul>
</li>
</ul>
</li>
<li>
<p>公平共享调度算法</p>
<ul>
<li>公平共享调度控制用户对系统资源的访问</li>
</ul>
</li>
</ul>
<h2 id="实时操作系统"><a class="header" href="#实时操作系统">实时操作系统</a></h2>
<ul>
<li>
<p>定义:正确性依赖于其 <strong>时间</strong> 和 <strong>功能</strong> 两方面的操作系统</p>
</li>
<li>
<p>实时操作系统的性能指标</p>
<ul>
<li>时间约束的及时性</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>
<p>分类</p>
<ul>
<li>强实时操作系统
<ul>
<li>要求在指定时间内必须完成重要的任务</li>
</ul>
</li>
<li>弱实时操作系统
<ul>
<li>重要进程有高优先级</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hard deadline: 错过任务实现会导致灾难性后果;必须验证,在最坏的情况下能够满足实现</p>
</li>
<li>
<p>Soft deadline: 通常能满足任务时限;尽力保证满足任务时限</p>
</li>
<li>
<p>可调度性: 表示一个实时操作系统能够满足任务时限要求</p>
</li>
<li>
<p>实时调度算法</p>
<ul>
<li>速率单调调度算法: 通过 <strong>周期</strong> 安排优先级,周期越短优先级越高</li>
<li>最早截止时间优先算法: 截止时间越早优先级越高</li>
</ul>
</li>
<li>
<p>多处理器调度</p>
<ul>
<li>多个处理机组成一个多处理器系统</li>
<li>处理机间可负载共享</li>
<li>对称多处理机的进程分配:
<ul>
<li>静态进程分配</li>
<li>动态进程分配</li>
</ul>
</li>
<li>优先级反置: 操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象
<ul>
<li>解决方法: 优先级继承、优先级天花板协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="multiple-cores"><a class="header" href="#multiple-cores">Multiple Cores</a></h1>
<h2 id="cache-coherence"><a class="header" href="#cache-coherence">Cache Coherence</a></h2>
<ul>
<li>
<p>Broadcast</p>
</li>
<li>
<p>Flashing</p>
</li>
</ul>
<h2 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h2>
<h3 id="sqms-single-queue-multiprocessor-schedule"><a class="header" href="#sqms-single-queue-multiprocessor-schedule">SQMS (Single Queue Multiprocessor Schedule)</a></h3>
<ul>
<li>
<p>Lack of scalability.</p>
</li>
<li>
<p>Weak in cache affinity, violates the locality principle.</p>
</li>
<li>
<p>Let process run in the same CPU, load balance will be invalid.</p>
</li>
<li>
<p>Thus either assure the cache affinity or load balance.</p>
</li>
</ul>
<h3 id="mqms-multi-queue-multiprocessor-scheduling"><a class="header" href="#mqms-multi-queue-multiprocessor-scheduling">MQMS (Multi-Queue Multiprocessor Scheduling)</a></h3>
<ul>
<li>
<p>Queues assign to different CPUs, and the scheduling algorithms can be different.</p>
</li>
<li>
<p>所有进程都可以保持在一个 CPU 上。</p>
</li>
<li>
<p>容易造成负载不均。</p>
</li>
</ul>
<blockquote>
<p>例如：某一个 CPU 任务执行完毕后，该 CPU 处于空转状态。因此只有通过进程的跨 CPU 迁移才能实现负载均衡。</p>
</blockquote>
<ul>
<li>具有可扩展性，队列数可根据 CPU 数进行扩展。</li>
</ul>
<p><strong>如何进行进程工作的迁移？</strong></p>
<ul>
<li>Work stealing: 进程、页表基址等需要迁移。</li>
</ul>
<h2 id="smp-and-linux-kernel"><a class="header" href="#smp-and-linux-kernel">SMP and Linux Kernel</a></h2>
<p>Linux Kernel 2.4 的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 调度算法：<em>initial queue</em> 和 <em>expired queue</em>， 单队列机制。</p>
<p>Linux Kernel 2.6 的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 调度算法：由 Ingo Molnar 设计，由于 Linux 系统有 140 中优先级，因此用一个 140 维的数组存放。在 active bitarray 中寻找 left-most bit 的位置，并在 APA 中寻找 APA[x]， 从 APA[x] 中 dequeue 一个 process，对于当前执行完的 process，重新计算 priority 再 enqueue 到 expired priority array 相应的队列 EPA[x] 中。在一定时间间隔后，要进行 load balance 分析。</p>
<p><strong>操作系统内核和驱动程序属于动态链接库。</strong></p>
<p>CPS 算法：通过计算进程消耗的 CPU 时间而不是优先级来进行调度。占用的资源越少，优先级就越高。但有些进程相比于其他进程更加重要即使执行的时间很长，因此会对每个进程进行赋权。分配给进程的运行时间 = 调度周期 × 进程权重/总权重之和。
Linux 引入 vruntime 进行计算：实际运行时间 × 1024/进程权重。</p>
<p>问题：新进程的 vruntime 为 0，则在相当长时间内都会保持抢占 CPU 的优势，因此应该设定一个最小值从而与老进程保持在一个合理的差距范围内。</p>
<p>休眠进程在唤醒后的 vruntime 相比于其他 active 进程较小，因此会强占 CPU，因此在进程重新唤醒后应该对 vruntime 进行一些补偿。在 Linux 中 sched_features 的 WAKEUP_PREEMPT 位决定在休眠后是否主动强占 CPU。</p>
<p>进程从一个 CPU 迁移到另一个 CPU 上时 vruntime 会不会变？
当一个进程从 CPU_x 出去并进入 CPU_y 的运行队列中时，它的 vruntime = vruntime - min_vruntime_x + min_vruntime_y。 </p>
<p>同时 vrumtime 可能会溢出，因此在比较 vruntime 的时候应该先减去 min_vruntime。</p>
<h2 id="bfs-brain-fuck-scheduler"><a class="header" href="#bfs-brain-fuck-scheduler">(BFS) Brain Fuck Scheduler</a></h2>
<p>一种时间片轮转算法的变种，在多处理机情况的但就绪队列选择，增加了队列互斥访问的开销。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="communication"><a class="header" href="#communication">Communication</a></h1>
<h2 id="并发进程的正确性"><a class="header" href="#并发进程的正确性">并发进程的正确性</a></h2>
<h3 id="独立进程"><a class="header" href="#独立进程">独立进程</a></h3>
<ul>
<li>不和其他进程共享资源或状态</li>
<li><strong>确定性</strong>：输入状态决定结果</li>
<li><strong>可重现</strong>：能够重现其实太监</li>
<li>调度顺序不重要</li>
</ul>
<h3 id="并发进程"><a class="header" href="#并发进程">并发进程</a></h3>
<ul>
<li>在多个进程间有资源共享</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
<h3 id="并发正确性"><a class="header" href="#并发正确性">并发正确性</a></h3>
<ul>
<li>执行过程是不确定和不可重现的</li>
<li>程序错误可能是间歇性发生的</li>
</ul>
<h3 id="并发执行的好处"><a class="header" href="#并发执行的好处">并发执行的好处</a></h3>
<ul>
<li>共享资源</li>
<li>加速执行</li>
</ul>
<h2 id="原子操作"><a class="header" href="#原子操作">原子操作</a></h2>
<p>不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换。</p>
<h2 id="原子锁"><a class="header" href="#原子锁">原子锁</a></h2>
<p>Lock.acquire() and Lock.release()</p>
<h2 id="进程的交互关系"><a class="header" href="#进程的交互关系">进程的交互关系</a></h2>
<ul>
<li>mutual exclusion</li>
<li>deadlock</li>
<li>starvation</li>
</ul>
<h2 id="critical-section"><a class="header" href="#critical-section">Critical Section</a></h2>
<ul>
<li>
<p>访问临界资源的代码，任何时候都要互斥执行</p>
</li>
<li>
<p>entry section：检查是否可进入临界区的一段代码,如可进入就设置正在访问临界区标志。</p>
</li>
<li>
<p>exit section: 清除标志。</p>
</li>
<li>
<p>remainder section: 其他部分。</p>
</li>
<li>
<p>临界区访问规则：空闲则入，忙则等待，有效等待，让权等待（可选）</p>
</li>
<li>
<p>实现方法：禁用硬件中断方法、软件方法、更高级的抽象方法。</p>
</li>
</ul>
<h3 id="禁用硬件中断"><a class="header" href="#禁用硬件中断">禁用硬件中断</a></h3>
<ul>
<li>没有中断，就没有上下文切换，因此没有并发</li>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>缺点：进程无法被停止下来，并发度较低；临界区很长，无法确定响应中断所需要的时间。
·</li>
</ul>
<h2 id="基于软件的同步解决方案"><a class="header" href="#基于软件的同步解决方案">基于软件的同步解决方案</a></h2>
<ul>
<li>
<p>方法一：共享变量 <code>turn</code>，表示某线程在临界区。满足「忙则等待」，但有时不满足「空闲则入」。</p>
</li>
<li>
<p>方法二：共享 <code>flag[]</code> 数组，表示线程[] 是否在临界区。存在的问题，两个线程同时 check 对方，不满足忙则等待。</p>
</li>
<li>
<p>方法三：共享 <code>flag[]</code> 数组，表示线程[] 是否想在临界区。如果其他人想，等待；只有自己想，进入。不满足空闲则入，例如两个进程同时想进来。</p>
</li>
<li>
<p>Peterson 算法：两个变量 <code>turn</code> 和 <code>flag[]</code>，<code>flag[]</code> 表示准备进入临界区。但两个进程同时想进入会出现 deadlock。</p>
</li>
<li>
<p>Dekkers 算法</p>
</li>
</ul>
<h2 id="高级抽象的同步方法"><a class="header" href="#高级抽象的同步方法">高级抽象的同步方法</a></h2>
<ul>
<li>锁是一种抽象的数据结构
<ul>
<li>二进制变量（锁定、解锁）</li>
<li>Lock::Acquire</li>
<li>Lock::Release</li>
</ul>
</li>
</ul>
<h2 id="原子操作-1"><a class="header" href="#原子操作-1">原子操作</a></h2>
<ul>
<li>Test and set</li>
<li>exchange</li>
</ul>
<h2 id="用-ts-指令实现自旋锁"><a class="header" href="#用-ts-指令实现自旋锁">用 TS 指令实现自旋锁</a></h2>
<h3 id="test-and-value"><a class="header" href="#test-and-value">Test and value</a></h3>
<pre><code class="language-c++">class Lock {
    int value = 0;
}

Lock::Acquire() {
    while(test-and-set(value)); //spin
}

Lock::Release() {
    value = 0;
}
</code></pre>
<h3 id="exchange"><a class="header" href="#exchange">Exchange</a></h3>
<pre><code class="language-c++">class Lock {
    bool tmp = 1, value = 0;
}

Lock::Acquire() {
    do {XCHG(&amp;value, &amp;tmp);}
    while(tmp == 1);
}

Lock::Release() {
    value = 0;
}
</code></pre>
<p>在锁的数据结构里加上一个等待队列。如果 value 是 0，则将其置 1，不进入 while 循环中；如果 value 是1，则进入 while 循环，将此进程写入到等待队列中，并执行调度程序，其他进程可以继续执行。<br />
释放锁时，把等待队列中的进程写入到就绪队列。
这种方法，使用放弃 CPU 使用权的方式来提高 CPU 利用效率。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<ul>
<li>锁是一种高级的同步抽象方法
<ul>
<li>互斥可以使用锁来实现</li>
<li>需要硬件支持</li>
</ul>
</li>
<li>常用的三种同步实现方法
<ul>
<li>禁用中断（仅限于单处理器）</li>
<li>软件方法（复杂）</li>
<li>原子操作指令（单处理器或多处理器均可）</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="semaphore"><a class="header" href="#semaphore">Semaphore</a></h1>
<p>程序员需要能应用信号量机制，比较繁琐。</p>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="monitor"><a class="header" href="#monitor">Monitor</a></h1>
<p>管程是一种用于多线程互斥访问共享资源的程序结构</p>
<ul>
<li>采用面向对象的方法，简化</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
